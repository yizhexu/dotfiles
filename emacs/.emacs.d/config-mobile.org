# -*- mode: org -*-
* Version

#+BEGIN_SRC emacs-lisp
emacs-version
#+END_SRC

#+RESULTS:
: 26.3

* Package Management

** =package=

package.el is a package manager for emacs modes

#+begin_src emacs-lisp
(require 'package)

(let* ((no-ssl (and (memq system-type '(windows-nt ms-dos))
                    (not (gnutls-available-p))))
       (proto (if no-ssl "http" "https")))
  (when no-ssl
    (warn "\
  Your version of Emacs does not support SSL connections,
  which is unsafe because it allows man-in-the-middle attacks.
  There are two things you can do about this warning:
  1. Install an Emacs version that does support SSL and be safe.
  2. Remove this warning from your init file so you won't see it again."))
  ;; Comment/uncomment these two lines to enable/disable MELPA and MELPA Stable as desired
  (add-to-list 'package-archives (cons "melpa" (concat proto "://melpa.org/packages/")) t)
  ;;(add-to-list 'package-archives (cons "melpa-stable" (concat proto "://stable.melpa.org/packages/")) t)
  ;;(add-to-list 'package-archives (cons "org" (concat proto "://orgmode.org/elpa")) t)
  (when (< emacs-major-version 24)
    ;; For important compatibility libraries like cl-lib
    (add-to-list 'package-archives (cons "gnu" (concat proto "://elpa.gnu.org/packages/")))))

(package-initialize)
#+end_src

** =use-package=

I'm switching [[https://stackoverflow.com/questions/21064916/auto-install-emacs-packages-with-melpa][too]]

#+begin_src emacs-lisp
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))

(eval-when-compile
  (require 'use-package))

(setq use-package-always-ensure t)
#+end_src

* UI

** Theme

#+begin_src emacs-lisp
(use-package afternoon-theme
  :config
  (load-theme 'afternoon t)
  ;; (transparency 93)
  (let ((line (face-attribute 'mode-line :underline)))
    (set-face-attribute 'mode-line          nil :overline   line)
    (set-face-attribute 'mode-line-inactive nil :overline   line)
    (set-face-attribute 'mode-line-inactive nil :underline  line)
    (set-face-attribute 'mode-line          nil :box        nil)
    (set-face-attribute 'mode-line-inactive nil :box        nil)))
#+end_src

** Simplify UI
*** Top Bar

Maximize screen room

 #+BEGIN_SRC emacs-lisp
 (if (fboundp 'menu-bar-mode) (menu-bar-mode -1))
 (if (fboundp 'tool-bar-mode) (tool-bar-mode -1))
 (if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
 #+END_SRC

 replace the active region just by typing text, just like modern editors

 #+BEGIN_SRC emacs-lisp
 (delete-selection-mode +1)
 #+END_SRC

*** Startup Message

#+BEGIN_SRC emacs-lisp
(setq inhibit-startup-message t
      initial-scratch-message ""
      inhibit-startup-echo-area-message t)
#+END_SRC

** Unicode

#+BEGIN_SRC emacs-lisp
(set-language-environment "UTF-8")
(set-default-coding-systems 'utf-8)
#+END_SRC

** Pretty Symbols

#+BEGIN_SRC emacs-lisp
(global-prettify-symbols-mode 1)

(setq prettify-symbols-alist
      '(
        ("lambda" . 955) ; λ
        ("->" . 8594)    ; →
        ("=>" . 8658)    ; ⇒
        ("map" . 8614)    ; ↦
        ))
#+END_SRC


** Yes or No

#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** Tabs

#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil)
#+END_SRC

** Fill Width

#+BEGIN_SRC emacs-lisp
(setq fill-column 80)
#+END_SRC

** Buffer / File Warnings

checks whether the parent directories exist for a given file and
offers to create them if they do not exist ([[http://iqbalansari.me/blog/2014/12/07/automatically-create-parent-directories-on-visiting-a-new-file-in-emacs/][Source]])

#+BEGIN_SRC emacs-lisp
(setq confirm-nonexistent-file-or-buffer nil)

(defun create-non-existent-directory ()
  "Check whether a given file's parent directories exist; if they do not, offer to create them."
  (let ((parent-directory (file-name-directory buffer-file-name)))
    (when (and (not (file-exists-p parent-directory))
               (y-or-n-p (format "Directory `%s' does not exist! Create it?" parent-directory)))
      (make-directory parent-directory t))))

(add-to-list 'find-file-not-found-functions #'create-non-existent-directory)
#+END_SRC

** Minibuffer

Sometimes cursor get stuck in minibuffer is annoying

#+BEGIN_SRC emacs-lisp
  (setq minibuffer-prompt-properties
        (quote
         (read-only t point-entered minibuffer-avoid-prompt face minibuffer-prompt)))
#+END_SRC

** Parentheses

Visual indication of matching pairs of parentheses

#+BEGIN_SRC emacs-lisp
(use-package smartparens
  :bind
  (("C-M-f" . sp-forward-sexp)
   ("C-M-b" . sp-backward-sexp)
   ("C-M-d" . sp-down-sexp)
   ("C-M-a" . sp-backward-down-sexp)
   ("C-S-a" . sp-beginning-of-sexp)
   ("C-S-d" . sp-end-of-sexp)
   ("C-M-e" . sp-up-sexp)
   ("C-M-u" . sp-backward-up-sexp)
   ("C-M-t" . sp-transpose-sexp)
   ("C-M-n" . sp-next-sexp)
   ("C-M-p" . sp-previous-sexp)
   ("C-M-k" . sp-kill-sexp)
   ("C-M-w" . sp-copy-sexp)
   ("M-<delete>" . sp-unwrap-sexp)
   ("M-S-<backspace>" . sp-backward-unwrap-sexp)
   ("C-<right>" . sp-forward-slurp-sexp)
   ("C-<left>" . sp-forward-barf-sexp)
   ("C-M-<left>" . sp-backward-slurp-sexp)
   ("C-M-<right>" . sp-backward-barf-sexp)
   ("M-D" . sp-splice-sexp)
   ("C-M-<delete>" . sp-splice-sexp-killing-forward)
   ("C-M-<backspace>" . sp-splice-sexp-killing-backward)
   ("C-M-S-<backspace>" . sp-splice-sexp-killing-around)
   ("C-]" . sp-select-next-thing-exchange)
   ("C-<left_bracket>" . sp-select-previous-thing)
   ("C-M-]" . sp-select-next-thing)
   ("M-F" . sp-forward-symbol)
   ("M-B" . sp-backward-symbol)
   ("H-t" . sp-prefix-tag-object)
   ("H-p" . sp-prefix-pair-object)
   ("H-s c" . sp-convolute-sexp)
   ("H-s a" . sp-absorb-sexp)
   ("H-s e" . sp-emit-sexp)
   ("H-s p" . sp-add-to-previous-sexp)
   ("H-s n" . sp-add-to-next-sexp)
   ("H-s j" . sp-join-sexp)
   ("H-s s" . sp-split-sexp)
   ("M-9" . sp-backward-sexp)
   ("M-0" . sp-forward-sexp))
  :init
  (smartparens-global-mode t)
  (show-smartparens-global-mode t)
  (use-package smartparens-config
    :ensure f)
  ;;; FIXME: Symbol’s value as variable is void: toggle-map
  ;; (bind-key "s" 'smartparens-mode toggle-map)
  ;; (when (is-mac-p)
  ;;   (bind-keys ("<s-right>" . sp-forward-slurp-sexp)
  ;;              ("<s-left>" . sp-forward-barf-sexp)))
  (sp-with-modes '(markdown-mode gfm-mode)
    (sp-local-pair "*" "*"))
  (sp-with-modes '(org-mode)
    (sp-local-pair "*" "*")
    (sp-local-pair "=" "=")
    (sp-local-pair "/" "/")
    (sp-local-pair "(" ")")
    (sp-local-pair "[" "]"))
  (use-package rainbow-delimiters
    :hook (prog-mode . rainbow-delimiters-mode)))
#+END_SRC


** Whitespace

#+BEGIN_SRC emacs-lisp
(add-hook 'before-save-hook 'whitespace-cleanup)
#+END_SRC

** Zooming
*** Hydra

#+BEGIN_SRC emacs-lisp
(use-package hydra
   :config
   (setq hydra-lv nil))
#+END_SRC

*** Key Binding

#+BEGIN_SRC emacs-lisp
 (defhydra hydra-zoom ()
   "zoom"
   ("+" text-scale-increase "in")
   ("=" text-scale-increase "in")
   ("-" text-scale-decrease "out")
   ("_" text-scale-decrease "out")
   ("0" (text-scale-adjust 0) "reset")
   ("q" nil "quit" :color blue))

 (bind-keys ("C-x C-0" . hydra-zoom/body)
            ("C-x C-=" . hydra-zoom/body)
            ("C-x C--" . hydra-zoom/body)
            ("C-x C-+" . hydra-zoom/body))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun vsplit-last-buffer ()
  (interactive)
  (split-window-vertically)
  (other-window 1 nil)
  (switch-to-next-buffer))

(defun hsplit-last-buffer ()
  (interactive)
  (split-window-horizontally)
  (other-window 1 nil)
  (switch-to-next-buffer))

(bind-key "C-x 2" 'vsplit-last-buffer)
(bind-key "C-x 3" 'hsplit-last-buffer)
#+END_SRC

* Security
** TLS

#+BEGIN_SRC emacs-lisp
(setq tls-checktrust t
      gnutls-verify-error t)
;; FIXME:  workaround to fix https not working well with elpa
;; https://www.reddit.com/r/orgmode/comments/cvmjjr/workaround_for_tlsrelated_bad_request_and_package/
(when
  (and
    (>= libgnutls-version 30603)
    (version<= emacs-version "26.2")
  )
(setq gnutls-algorithm-priority "NORMAL:-VERS-TLS1.3"))
#+END_SRC

** Encryption

Force emacs to use its own password prompt ([[https://github.com/mwfogleman/.emacs.d/blob/master/michael.org#encryption][Source]])

#+BEGIN_SRC emacs-lisp
  (setenv "GPG_AGENT_INFO" nil)
#+END_SRC

** Pass

#+BEGIN_SRC emacs-lisp
(use-package pass)
#+END_SRC

* Saving
** Backups

 Store backups and auto-saved files in a fixed location rather in the
 same directory as the file.

 #+BEGIN_SRC emacs-lisp
 (let ((backup-dir "~/Documents/backups")
       (auto-saves-dir "~/Documents/auto-saves/"))
   (dolist (dir (list backup-dir auto-saves-dir))
     (when (not (file-directory-p dir))
       (make-directory dir t)))
   (setq backup-directory-alist `(("." . ,backup-dir))
         auto-save-file-name-transforms `((".*" ,auto-saves-dir t))
         auto-save-list-file-prefix (concat auto-saves-dir ".saves-")
         tramp-backup-directory-alist `((".*" . ,backup-dir))
         tramp-auto-save-directory auto-saves-dir))

 (setq backup-by-copying t    ; Don't delink hardlinks
       delete-old-versions t  ; Clean up the backups
       version-control t      ; Use version numbers on backups,
       kept-new-versions 5    ; keep some new versions
       kept-old-versions 2)   ; and some old ones, too
 #+END_SRC

** Save Place

If you close a buffer, it remembers where you were in the file, so
that when you re-open that file the buffer goes straight to that
place. The configuration of this mode is very simple as of Emacs 25.1.

#+BEGIN_SRC emacs-lisp

(setq-default save-place t)
(setq save-place-file (expand-file-name ".places" user-emacs-directory))

(save-place-mode 1)
#+END_SRC

* Key Bindings`
** Lines

Enable line indenting automatically. If needed, you can disable on a mode-by-mode basis.

#+BEGIN_SRC emacs-lisp
(bind-keys ("RET" . newline-and-indent)
           ("C-j" . newline-and-indent))
#+END_SRC

Make C-n insert new lines if the point is at the end of the buffer.

#+BEGIN_SRC emacs-lisp
(setq next-line-add-newlines t)
#+END_SRC

** Scrolling

#+BEGIN_SRC emacs-lisp
;; better scrolling experience
(setq scroll-margin 0
      scroll-conservatively 10000
      scroll-preserve-screen-position t
      auto-window-vscroll nil)
#+END_SRC

There are lots of neat ways of moving around quickly in a
buffer. (Source: [[http://whattheemacsd.com/key-bindings.el-02.html][What the .emacs.d?]])

#+BEGIN_SRC emacs-lisp
(defun super-next-line ()
  (interactive)
  (ignore-errors (next-line 5)))

(defun super-previous-line ()
  (interactive)
  (ignore-errors (previous-line 5)))

(defun super-backward-char ()
  (interactive)
  (ignore-errors (backward-char 5)))

(defun super-forward-char ()
  (interactive)
  (ignore-errors (forward-char 5)))

(bind-keys ("C-S-n" . super-next-line)
           ("C-S-p" . super-previous-line)
           ("C-S-b" . super-backward-char)
           ("C-S-f" . super-forward-char))
#+END_SRC

** backward-kill-line

This binding comes from Emacs Redux.

#+BEGIN_SRC emacs-lisp
  (bind-key "C-<backspace>" (lambda ()
                              (interactive)
                              (kill-line 0)
                              (indent-according-to-mode)))

#+END_SRC

** Cycle Spacing

#+BEGIN_SRC emacs-lisp
  (bind-key "C-x SPC" 'cycle-spacing)
#+END_SRC
** which-key

#+BEGIN_SRC emacs-lisp
(use-package which-key
  :diminish which-key-mode
  :defer 1
  :config
  (which-key-mode +1)
  (setq which-key-idle-delay 0.4
        which-key-idle-secondary-delay 0.4))
#+END_SRC

** Interaction Log

Interaction Log is like view-lossage (C-h l) or kmacro-edit-macro but
it is live-updating and not tied to macros. It’s useful for when you
type an (awesome? terrible?) Emacs command and want to figure out
which function you used so you can use it again or destroy it
forever. For a long time I was plagued by accidentally hitting
downcase-region and didn’t know what the function was - this would
have been so useful!

#+BEGIN_SRC emacs-lisp
(use-package interaction-log)

(interaction-log-mode +1)

(defun open-interaction-log ()
  (interactive)
  (display-buffer ilog-buffer-name))

(bind-key "C-h C-l" 'open-interaction-log)
#+END_SRC

* Programming
** Path

Define append to path method

#+BEGIN_SRC emacs-lisp
(defun yizhe/append-to-path (path)
  "Add a path both to the $PATH variable and Emacs's path"
  (setenv "PATH" (concat (getenv "PATH") ":" path))
  (add-to-list 'exec-path path))
#+END_SRC

Append path of my programs

#+BEGIN_SRC emacs-lisp
(yizhe/append-to-path "/usr/bin")
(yizhe/append-to-path "/usr/local/bin")
#+END_SRC

** Eshell

Testing this out

#+BEGIN_SRC emacs-lisp
  (use-package eshell
    :bind (("<f1>" . eshell))
    :hook ((eshell-mode . with-editor-export-editor)
           (eshell-mode . setup-company-eshell-autosuggest))
    :init
    (setq eshell-banner-message "")

    (defun new-eshell ()
      (interactive)
      (eshell 'true))

    (use-package esh-autosuggest
      :init
      (defun setup-company-eshell-autosuggest ()
        (with-eval-after-load 'company
          (setq-local company-backends '(esh-autosuggest))
          (setq-local company-frontends '(company-preview-frontend))))))
#+END_SRC

*** Some eshell functions

[[https://justin.abrah.ms/dotfiles/emacs.html][source]]

#+BEGIN_SRC emacs-lisp
(defun eshell/extract (file)
  (eshell-command-result (concat (if-string-match-then-result
                                  file
                                  '((".*\.tar.bz2" "tar xjf")
                                    (".*\.tar.gz" "tar xzf")
                                    (".*\.bz2" "bunzip2")
                                    (".*\.rar" "unrar x")
                                    (".*\.gz" "gunzip")
                                    (".*\.tar" "tar xf")
                                    (".*\.tbz2" "tar xjf")
                                    (".*\.tgz" "tar xzf")
                                    (".*\.zip" "unzip")
                                    (".*\.jar" "unzip")
                                    (".*\.Z" "uncompress")
                                    (".*" "echo 'Could not extract the requested file:'")))
                                 " " file)))

(defun eshell/clear ()
  "clear the eshell buffer."
  (interactive)
  (let ((inhibit-read-only t))
    (erase-buffer)))
#+END_SRC
** Emacs Lisp
*** Elisp-Slime-Nav
#+BEGIN_SRC emacs-lisp
(use-package elisp-slime-nav
  :init
  (dolist (hook '(emacs-lisp-mode-hook ielm-mode-hook))
    (add-hook hook 'elisp-slime-nav-mode)))
#+END_SRC

*** Eldoc

When in emacs-lisp-mode, display the argument list for the current
function.

#+BEGIN_SRC emacs-lisp
(autoload 'turn-on-eldoc-mode "eldoc" nil t)
(add-hook 'emacs-lisp-mode-hook 'eldoc-mode)
(add-hook 'lisp-interaction-mode-hook 'eldoc-mode)
(add-hook 'ielm-mode-hook 'eldoc-mode)
(add-hook 'cider-mode-hook 'eldoc-mode)
#+END_SRC

** Git
*** magit

#+BEGIN_SRC emacs-lisp
(use-package magit
  :bind (("C-x g" . magit-status)
         ("C-c g" . magit-status)
         :map magit-status-mode-map
         ("TAB" . magit-section-toggle)
         ("<C-tab>" . magit-section-cycle)
         :map magit-branch-section-map
         ("RET" . magit-checkout))
  :config
  (add-hook 'after-save-hook 'magit-after-save-refresh-status)
  (setq magit-use-overlays nil
        magit-section-visibility-indicator nil
        magit-completing-read-function 'ivy-completing-read
        magit-push-always-verify nil
        magit-repository-directories '("~/src/"))
  (use-package git-timemachine
    :bind (("C-x v t" . git-timemachine)))
  (use-package git-link
    :bind (("C-x v L" . git-link))
    :init
    (setq git-link-open-in-browser t))
  (use-package pcmpl-git)
  (defun visit-pull-request-url ()
    "Visit the current branch's PR on Github."
    (interactive)
    (browse-url
     (format "https://github.com/%s/pull/new/%s"
             (replace-regexp-in-string
              "\\`.+github\\.com:\\(.+\\)\\.git\\'" "\\1"
              (magit-get "remote"
                         (magit-get-remote)
                         "url"))
             (cdr (magit-get-remote-branch)))))

  (bind-key "v" 'visit-pull-request-url magit-mode-map)

  ;; Do Not Show Recent Commits in status window
  ;; https://github.com/magit/magit/issues/3230#issuecomment-339900039
  (magit-add-section-hook 'magit-status-sections-hook
                          'magit-insert-unpushed-to-upstream
                          'magit-insert-unpushed-to-upstream-or-recent
                          'replace))
#+END_SRC

*** Git Auto Commit Mode

#+BEGIN_SRC emacs-lisp
(use-package git-auto-commit-mode
  :delight)
#+END_SRC

* Writing
** =org-mode=

[[http://xahlee.info/comp/unicode_index.html][Unicode!]]

#+BEGIN_SRC emacs-lisp
(use-package org
  :bind (("C-c c" . org-capture)
         ("C-c a" . org-agenda)
         ("C-c b" . org-iswitchb)
         ("C-c M-k" . org-cut-subtree)
         :map org-mode-map
         ("C-c >" . org-time-stamp-inactive))
  :custom-face
  (variable-pitch ((t (:family "ETBembo"))))
  (org-done ((t (:strike-through t ))))
  (org-headline-done ((t ( :strike-through t))))
  (org-image-actual-width '(600))
  :init
  (setq default-major-mode 'org-mode
        ;; startup behavior
        org-startup-folded t
        org-startup-indented t
        org-startup-truncated nil
        org-startup-with-inline-images t

        ;; files
        org-directory "~/Documents/yizhe/"
        org-default-notes-file (concat org-directory "index.org")
        org-agenda-files (list org-directory)

        ;; the look
        org-blank-before-new-entry '((heading . always) (plain-list-item . auto))
        org-src-fontify-natively t
        org-pretty-entities t
        org-src-preserve-indentation t
        org-hide-emphasis-markers t ;; show actually italicized text instead of /italicized text/
        org-ellipsis "⤵" ;; foldings symbol
        org-fontify-whole-heading-line t
        org-fontify-done-headline t
        org-fontify-quote-and-verse-blocks t
        org-format-latex-options (plist-put org-format-latex-options :scale 1.5)
        org-footnote-auto-adjust t
        org-footnote-auto-label t
        org-use-sub-superscripts '{} ;; underscores, etc needs to be wraped as a_{underscore}

        ;; other behavior
        org-confirm-babel-evaluate nil
        org-id-method (quote uuidgen)
        org-file-apps
        '((auto-mode . emacs)
          ("\\.mm\\'" . default)
          ("\\.x?html?\\'" . "firefox %s")
          ("\\.pdf\\'" . "open %s"))
        ;; org-enforce-todo-dependencies t ;; parent should not be marked as done if children are note

        org-completion-use-ido t
        org-default-priority ?B

        ;; navigation
        org-special-ctrl-a/e t ;; C-a to beginning, C-e to end
        org-goto-max-level 10
        org-goto-interface 'outline-path-completion
        org-image-actual-width '(300)
        org-imenu-depth 5
        org-show-notification-handler 'message
        org-src-window-setup 'current-window
        org-tags-column 80

        ;; org todos
        org-todo-keywords '((sequence "TODO(t)" "STARTED(s)" "FOLLOWUP(f)" "WAITING(w)" "|" "DONE(x!)" "CANCELLED(c)" "|" "MEETING(m)"))
        org-tag-persistent-alist '(("read" . ?r)
                                   ("write" . ?w)
                                   ("idea" . ?i))

        org-outline-path-complete-in-steps nil
        org-lowest-priority ?C
        org-yank-adjusted-subtrees t

        ;; archiving
        org-archive-mark-done nil
        org-archive-location "%s_archive::* Archived Tasks"
        )

  (add-hook 'org-mode-hook 'flyspell-mode)

  (add-hook 'org-mode-hook
            '(lambda ()
               "Beautify Org Checkbox Symbol"
               (push '("TODO"  . ?▲) prettify-symbols-alist)
               (push '("STARTED"  . ?♫) prettify-symbols-alist)
               (push '("FOLLOWUP"  . ??) prettify-symbols-alist)
               (push '("WAITING" . ?⁕) prettify-symbols-alist)
               (push '("DONE"  . ?✓) prettify-symbols-alist)
               (push '("CANCELLED"  . ?✘) prettify-symbols-alist)
               (push '("MEETING" . ?✐) prettify-symbols-alist)
               (prettify-symbols-mode)
               ))
  )
#+END_SRC

** Capture

Configure my capture template!

When I do the following task, I use =C-c c= to capture it, including:
- recording a task
- a meeting
- do a journal entry of the day

Capture symbols
- =%?= test to entry
- =%U= gets this [2019-09-14 Sat 14:50]
- =%^U= prompts the schedule selector
- =%^G= interactively asking for tag

#+BEGIN_SRC emacs-lisp
(setq org-capture-templates
      (quote (("t" "Task")
              ("tt" "TODO" entry
               (file+headline org-default-notes-file "new")
               "* TODO %?\nSCHEDULED: %^U\n %^{Effort}p \n")
              ("tf" "FOLLOWUP" entry
               (file+headline org-default-notes-file "new")
               "* FOLLOWUP %?\nSCHEDULED: %^U")
              ("td" "DONE" entry
               (file+headline org-default-notes-file "new")
               "* DONE %?\nCLOSED: %U")

              ("m" "Meeting" entry
               (file org-default-notes-file "meeting")
               "* MEETING Meet with %? \nSCHEDULED: %^U")

              ("r" "Read")
              ("rc" "Important" entry
               (file+headline org-default-notes-file "read")
               "* TODO [#A] Read %? \n")
              ("rn" "Normal" entry
               (file+headline "~/Documents/yizhe/index.org" "read")
               "* TODO Read %?")

              ("j" "Journal" entry
               (file+datetree "~/Documents/yizhe/logbook.org")
               "* %?\n")
              )))


#+END_SRC

#+RESULTS:
| t | Task | entry | (file+headline ~/Documents/yizhe/index.org new) | * TODO %? |

** Refile

#+BEGIN_SRC emacs-lisp
(setq org-refile-targets '((org-agenda-files . (:maxlevel . 3)))
      ;; org-refile-use-cache t
      org-refile-use-outline-path t
      org-refile-allow-creating-parent-nodes (quote confirm)) ;; with confirmation, allow to create parent

#+END_SRC

Exclude completed tasks from refile targets, from Michael Englehorn’s Emacs Configuration.

#+BEGIN_SRC emacs-lisp
(defun verify-refile-target
    ()
  "Exclude todo keywords with a done state from refile targets"
  (not (member (nth 2 (org-heading-components)) org-done-keywords)))

(setq org-refile-target-verify-function 'verify-refile-target)
#+END_SRC

** =org-agenda=

*** Configuration

#+begin_src emacs-lisp
(setq
 ;; stop preparing agenda buffers on startup
 org-agenda-inhibit-startup t

 ;; blocks
 org-agenda-block-separator nil
 org-agenda-compact-blocks t
 org-agenda-show-future-repeats nil
 ;; weekly agenda start on monday
 org-agenda-start-on-weekday 1

 ;; skips
 org-agenda-skip-archived-trees t
 org-agenda-skip-deadline-if-done t
 org-agenda-skip-scheduled-if-done t

 org-agenda-window-setup 'current-window

 ;; hit r to rebuild agenda
 org-agenda-sticky t

 org-agenda-tags-column org-tags-column
 org-deadline-warning-days 5
 org-agenda-with-colors t

 org-agenda-sorting-strategy
 (quote
  ((agenda deadline-up priority-down)
   (todo priority-down category-keep)
   (tags priority-down category-keep)
   (search category-keep)))
 org-agenda-time-grid
 '((daily today require-timed)
   ()
   "......"
   ".................."))
#+end_src

Highlight current agenda line

#+BEGIN_SRC emacs-lisp
(add-hook 'org-agenda-mode-hook
          '(lambda () (hl-line-mode 1))
          'append)
#+END_SRC

*** =org-super-agenda=

#+BEGIN_SRC emacs-lisp
(use-package org-super-agenda
  :config (org-super-agenda-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq org-agenda-custom-commands
      '(("z" "Super view"
         ((agenda "" ((org-agenda-span 'day)
                      (org-super-agenda-groups
                       '((:name "Today"
                                :time-grid t
                                :habit t
                                :date today
                                :scheduled today)
                         (:name "Important"
                                :date today
                                :scheduled today
                                :priority "A")))))

          (alltodo "" ((org-agenda-overriding-header "")
                       (org-super-agenda-groups
                        '((:auto-group t)
                          (:name "Important"
                                 :priority "A")
                          (:name "Quick Picks"
                                 :effort< "0:30")
                          (:name "Due Soon"
                                 :deadline future)
                          (:name "Overdue"
                                 :deadline past)
                          (:name "To read"
                                 :tag "read")
                          (:name "To write"
                                 :tag "write")
                          (:name "Follow up"
                                 :todo "FOLLOWUP")))))))))
#+END_SRC

** Clocking

Use clocking to track time spend on tasks

*** Configuration

#+BEGIN_SRC emacs-lisp
(setq org-expiry-inactive-timestamps t
      org-log-done t
      org-clock-idle-time nil
      org-clock-continuously nil
      org-clock-persist t
      org-clock-persist-query-resume t ;; not prompt to resume an active clock
      org-clock-in-switch-to-state "STARTED"
      org-clock-in-resume t ;; resume clocking task on clock-in if the clock is open
      org-clock-out-when-done t
      org-clock-out-remove-zero-time-clocks t
      org-clock-report-include-clocking-task t ;; include current clocking task in clock reports
      ;; Too many clock entries clutter up a heading
      org-log-into-drawer nil
      org-clock-into-drawer 1 ;; save clock data and state changes and notes in the LOGBOOK drawer

      org-agenda-clockreport-parameter-plist (quote (:link t :maxlevel 5 :fileskip0 t :compact t :narrow 80)) ;; agenda clock report parameters
      org-columns-default-format "%80ITEM(Task) %10Effort(Effort){:} %10CLOCKSUM" ;; set default column view headings: Task Effort Clock_Summary

      )


(add-to-list 'org-global-properties
             '("Effort_ALL" . "0:15 0:30 0:45 1:00 1:30 2:00 3:00 4:00 6:00")) ; global Effort estimate values


(add-to-list 'org-global-properties
             '("STYLE_ALL" . "habit")) ; global STYLE property values for completion
#+END_SRC
*** Remove Empty Logbook Drawers

Remove empty LOGBOOK drawers on clock out, from [[https://michael.englehorn.com/config.html][Michael Englehorn's
Emacs Configuration]]. This [[https://stackoverflow.com/questions/21767471/org-capture-and-time-clocking-misbehaving#21797427][Stack Overflow post]] shows the fix to the bug
in the original function (remove the "LOGBOOK" specification).

#+BEGIN_SRC emacs-lisp
  (defun bh/remove-empty-drawer-on-clock-out ()
    (interactive)
    (save-excursion
      (beginning-of-line 0)
      (org-remove-empty-drawer-at (point))))

  (add-hook 'org-clock-out-hook 'bh/remove-empty-drawer-on-clock-out 'append)
#+END_SRC

*** Key Bindings

However, there are a *lot* of commands for clocking; this is a perfect instance for a Hydra.

#+BEGIN_SRC emacs-lisp
  (defhydra hydra-org-clock (:color blue :hint nil)
    "
  Clock   In/out^     ^Edit^   ^Summary     (_?_)
  -----------------------------------------
          _i_n         _e_dit   _g_oto entry
          _c_ontinue   _q_uit   _d_isplay
          _o_ut        ^ ^      _r_eport
        "
    ("i" org-clock-in)
    ("o" org-clock-out)
    ("c" org-clock-in-last)
    ("e" org-clock-modify-effort-estimate)
    ("q" org-clock-cancel)
    ("g" org-clock-goto)
    ("d" org-clock-display)
    ("r" org-clock-report)
    ("?" (org-info "Clocking commands")))

  (defhydra hydra-org-agenda-clock (:color blue :hint nil)
    "
  Clock   In/out^
  -----------------------------------------
          _i_n
          _g_oto entry
          _o_ut
          _q_uit
        "
    ("i" org-agenda-clock-in)
    ("o" org-agenda-clock-out)
    ("q" org-agenda-clock-cancel)
    ("g" org-agenda-clock-goto))

  (bind-keys ("C-c w" . hydra-org-clock/body)
             :map org-agenda-mode-map
             ("C-c w" . hydra-org-agenda-clock/body))
#+END_SRC

** Easy Bind To Open Todos

#+begin_src emacs-lisp
(defun open-todo-file ()
  (interactive)
  (find-file "~/Documents/yizhe/index.org"))

(bind-key "C-c t" 'open-todo-file)
#+end_src

** =org-bullets=

#+BEGIN_SRC emacs-lisp
  (use-package org-bullets
    :init
    :config
    (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))
#+END_SRC

** =org-modules=

 #+BEGIN_SRC emacs-lisp
(require 'org-install)
;; FIXME: workaround
;; https://github.com/syl20bnr/spacemacs/issues/11798
(when (version<= "9.2" (org-version))
  (require 'org-tempo))

(setq org-modules '(org-habit org-info))
(org-load-modules-maybe t)
 #+END_SRC

** =org-habits=

#+begin_src emacs-lisp
(setq org-habit-graph-column 48)
(setq org-habit-show-habits-only-for-today t)

(defun org-make-habit ()
  (interactive)
  (org-set-property "STYLE" "habit"))
#+end_src

A habit has a =SCHEDULE= tag with a repeat specification like =.+=, =++=, or
=+=. A =STYLE= property set to value habit.

For scheduling:

=.+2d/4d= means:

- Repeat as frequently as every two days, but
- Never less frequently than every four days, and
- When completed, start counting again from today.

=++= =means:

 from the last date completed, count as many 2-day intervals as
 necessary to find a date in the future. This is useful if you want
 something to always fall on the same days of the week

or plain =+= repeat, which is unusual for a habit, because if you fall
quite behind you will need to complete the task as many times as it
takes for the next occurrence to get into the future. This would be
useful for something like paying your rent where you cannot skip any
instances, but that isn’t really a habit.

** =org-babel=

Source code that =org-babel= wants to evaluate

#+BEGIN_SRC emacs-lisp
(org-babel-do-load-languages
 'org-babel-load-languages
 '((emacs-lisp . t)))
#+END_SRC

** Line Numbering

#+BEGIN_SRC emacs-lisp
(use-package linum-relative
  :init
  (setq linum-format 'linum-relative)
  :config
  (setq linum-relative-current-symbol ""))
#+END_SRC

** Indenting

#+BEGIN_SRC emacs-lisp
  (use-package aggressive-indent
    :init
    (global-aggressive-indent-mode 1)
    (add-to-list 'aggressive-indent-excluded-modes 'scala-mode)
    (unbind-key "C-c C-q" aggressive-indent-mode-map))
#+END_SRC

Use spaces instead of tab for intentation - 4 spaces

#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil
              tab-width 4)
#+END_SRC

* Functions
** Emacs Configuration File
This function and the corresponding keybinding allows me to rapidly
access my configuration. They are adapted from Bozhidar Batsov’s post
on Emacs Redux.

#+begin_src emacs-lisp
(defun find-config-file
    ()
  "Edit my emacs config file"
  (interactive)
  (let ((config-file "~/.emacs.d/config.org"))
    (find-file config-file)))

(bind-key "C-c e" 'find-config-file)
#+end_src

#+RESULTS:
: find-config-file

I use mwf-init-file rather than user-init-file, because I edit the
  config file in a Git repo.

#+BEGIN_SRC emacs-lisp
  (defun find-init-file ()
    "Edit my init file in another window."
    (interactive)
    (let ((mwf-init-file "~/.emacs.d/init.el"))
      (find-file mwf-init-file)))

#+END_SRC

Relatedly, I often want to reload my init-file. This will actually use the system-wide user-init-file variable.

#+BEGIN_SRC emacs-lisp
(defun reload-init-file ()
  "Reload my init file."
  (interactive)
  (load-file user-init-file))

(bind-key "C-c M-i" 'reload-init-file)
#+END_SRC
