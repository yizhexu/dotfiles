* About me

#+begin_src emacs-lisp
  (setq user-full-name "Yizhe Xu"
        user-mail-address "me@yizhexu.com"
        calendar-latitude 47.6133788
        calendar-longitude -122.3497462)
#+end_src

* Debug

#+BEGIN_SRC emacs-lisp
(setq debug-on-error t)
#+END_SRC

* Package Management

Emacs and org mode versions

#+BEGIN_SRC emacs-lisp
emacs-version
#+END_SRC

#+RESULTS:
: 26.3

package.el is a package manager for emacs modes

#+begin_src emacs-lisp
(require 'package)

(let* ((no-ssl (and (memq system-type '(windows-nt ms-dos))
                    (not (gnutls-available-p))))
       (proto (if no-ssl "http" "https")))
  (when no-ssl
    (warn "\
  Your version of Emacs does not support SSL connections,
  which is unsafe because it allows man-in-the-middle attacks.
  There are two things you can do about this warning:
  1. Install an Emacs version that does support SSL and be safe.
  2. Remove this warning from your init file so you won't see it again."))
  ;; Comment/uncomment these two lines to enable/disable MELPA and MELPA Stable as desired
  (add-to-list 'package-archives (cons "melpa" (concat proto "://melpa.org/packages/")) t)
  ;;(add-to-list 'package-archives (cons "melpa-stable" (concat proto "://stable.melpa.org/packages/")) t)
  ;;(add-to-list 'package-archives (cons "org" (concat proto "://orgmode.org/elpa")) t)
  (when (< emacs-major-version 24)
    ;; For important compatibility libraries like cl-lib
    (add-to-list 'package-archives (cons "gnu" (concat proto "://elpa.gnu.org/packages/")))))

(package-initialize)
#+end_src

** =use-package=

I'm switching [[https://stackoverflow.com/questions/21064916/auto-install-emacs-packages-with-melpa][too]]

#+begin_src emacs-lisp
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))

(eval-when-compile
  (require 'use-package))

(setq use-package-always-ensure t)
#+end_src

** Paradox

It is a modernizing Emacs' Package Menu with stars!

#+begin_src emacs-lisp
(use-package paradox
  :config
  (setq paradox-execute-asynchronously t))
#+end_src

* Detect
** Operating System

Different setup sometimes required for different operating system

#+begin_src emacs-lisp
(defun is-mac-p
    ()
  (eq system-type 'darwin))

(defun is-linux-p
    ()
  (eq system-type 'gnu/linux))

(defun is-windows-p
    ()
  (or
   (eq system-type 'ms-dos)
   (eq system-type 'windows-nt)
   (eq system-type 'cygwin)))

(defun is-bsd-p
    ()
  (eq system-type 'gnu/kfreebsd))
#+end_src

** User Login

#+BEGIN_SRC emacs-lisp
(defun is-yizhx
    ()
  (string-equal user-login-name "yizhx"))
#+END_SRC

** Internet

#+begin_src emacs-lisp
(defun internet-up-p (&optional host)
  (= 0 (call-process "ping" nil nil nil "-c" "1" "-W" "1"
                     (if host host "www.google.com"))))
#+end_src

* UI
** Transparency

Transparency looks nice

#+begin_src emacs-lisp
(defun transparency (value)
        "set transparency of the frame window. 0=transparent/ 100=opaque"
        (interactive "nTransparency Value 0-100 opaque:")
        (set-frame-parameter (selected-frame) 'alpha value))
#+end_src

** Theme

#+begin_src emacs-lisp
(use-package afternoon-theme
  :config
  (load-theme 'afternoon t)
  (transparency 93)
  (let ((line (face-attribute 'mode-line :underline)))
    (set-face-attribute 'mode-line          nil :overline   line)
    (set-face-attribute 'mode-line-inactive nil :overline   line)
    (set-face-attribute 'mode-line-inactive nil :underline  line)
    (set-face-attribute 'mode-line          nil :box        nil)
    (set-face-attribute 'mode-line-inactive nil :box        nil)))
#+end_src

** Simplify UI
*** Top Bar

Maximize screen room

 #+BEGIN_SRC emacs-lisp
 (if (fboundp 'menu-bar-mode) (menu-bar-mode -1))
 (if (fboundp 'tool-bar-mode) (tool-bar-mode -1))
 (if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
 #+END_SRC

 replace the active region just by typing text, just like modern editors

 #+BEGIN_SRC emacs-lisp
 (delete-selection-mode +1)
 #+END_SRC

*** Startup Message

#+BEGIN_SRC emacs-lisp
(setq inhibit-startup-message t
      initial-scratch-message ""
      inhibit-startup-echo-area-message t)
#+END_SRC

** Font

#+BEGIN_SRC emacs-lisp
(set-default-font "Hack")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(font-family-list)
#+END_SRC

** Line Spacing

#+BEGIN_SRC emacs-lisp
;; increase line space for better readability
(setq-default line-spacing 0.2)
#+END_SRC

** Unicode

#+BEGIN_SRC emacs-lisp
(set-language-environment "UTF-8")
(set-default-coding-systems 'utf-8)
#+END_SRC

** Fancy Lambdas

#+BEGIN_SRC emacs-lisp
(global-prettify-symbols-mode t)
#+END_SRC

** Pretty Symbols

#+BEGIN_SRC emacs-lisp
(global-prettify-symbols-mode +1)
#+END_SRC

** Neotree

#+BEGIN_SRC emacs-lisp
(use-package neotree
  :bind ([f8] . neotree-toggle))
#+END_SRC

** Mode Line

#+BEGIN_SRC emacs-lisp
(setq display-time-24hr-format t
      display-time-format "%a, %b %e %R"
      battery-mode-line-format "%p%%"  ; Default: "[%b%p%%]"
      global-mode-string   (remove 'display-time-string global-mode-string)
      mode-line-end-spaces (list (propertize " "
                                             'display '(space :align-to (- right 17)))
                                 'display-time-string))
(display-time-mode 1)
(display-time-update)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(unless (fboundp 'file-local-name)
  (defun file-local-name (file)
    "Return the local name component of FILE."
    (or (file-remote-p file 'localname) file)))

(setq mode-line-position
      '((line-number-mode ("(%l" (column-number-mode ",%c")))
        (-4 ":%p" ) (")")))

(defun modeline-project-root ()
  "Get the path to the root of your project.
Return `default-directory' if no project was found."
  (file-local-name
   (or
    (when (featurep 'projectile)
      (ignore-errors (projectile-project-root)))
    default-directory)))

(defun truncate-relative-path (path)
  "Return the truncate of relative PATH."
  (save-match-data
    (let ((pos 0) matches)
      (setq path (concat "/" path))
      (while (string-match "\\(\/\\.?.\\)" path pos)
        (setq matches (concat matches (match-string 0 path)))
        (setq pos (match-end 0)))
      (concat matches "/"))))

(defun modeline-buffer-file-name ()
  "Propertized variable `buffer-file-name'."
  (let* ((buffer-file-truename (file-local-name (or (buffer-file-name (buffer-base-buffer)) "")))
         (project-root (modeline-project-root)))
    (concat
     ;; project
     (propertize
      (concat (file-name-nondirectory (directory-file-name project-root)) "/")
      'face '(:inherit font-lock-string-face :weight bold))
     ;; relative path
     (propertize
      (when-let (relative-path (file-relative-name
                                (or (file-name-directory buffer-file-truename) "./")
                                project-root))
        (if (string= relative-path "./") ""
          (substring (truncate-relative-path relative-path) 1)))
      'face 'font-lock-comment-face)
     ;; file name
     (propertize (file-name-nondirectory buffer-file-truename)
                 'face 'mode-line-buffer-id))))

(defvar-local modeline-buffer-info nil)
(defvar mode-line-buffer-info
  '(:propertize
    (:eval (or modeline-buffer-info
               (setq modeline-buffer-info
                     (if buffer-file-name
                         (modeline-buffer-file-name)
                       (propertize "%b" 'face '(:weight bold))))))))
(put 'mode-line-buffer-info 'risky-local-variable t)

(defsubst modeline-column (pos)
  "Get the column of the position `POS'."
  (save-excursion (goto-char pos)
                  (current-column)))
(defun selection-info()
  "Information about the current selection."
  (when mark-active
    (cl-destructuring-bind (beg . end)
        (cons (region-beginning) (region-end))
      (propertize
       (let ((lines (count-lines beg (min end (point-max)))))
         (concat (cond ((bound-and-true-p rectangle-mark-mode)
                        (let ((cols (abs (- (modeline-column end)
                                            (modeline-column beg)))))
                          (format "(%dx%d)" lines cols)))
                       ((> lines 1)
                        (format "(%d,%d)" lines (- end beg)))
                       ((format "(%d,%d)" 0 (- end beg))))))
       'face 'font-lock-warning-face))))

(setq-default mode-line-format
              '("%e"
                mode-line-front-space
                mode-line-mule-info
                mode-line-client
                mode-line-modified
                mode-line-remote
                ;; mode-line-frame-identification -- this is for text-mode emacs only
                " "
                mode-line-buffer-info
                ;; mode-line-buffer-identification
                " "
                mode-line-position
                (:eval (selection-info))
                (vc-mode vc-mode)
                " "
                mode-line-modes
                ;;mode-line-misc-info
                mode-line-end-spaces))
#+END_SRC

** Battery

#+BEGIN_SRC emacs-lisp
  (when (is-mac-p)
    (display-battery-mode 1))
#+END_SRC

** Yes or No

#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** Tabs

#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil)
#+END_SRC

** Fill Width

#+BEGIN_SRC emacs-lisp
(setq fill-column 80)
#+END_SRC

** Buffer / File Warnings

checks whether the parent directories exist for a given file and
offers to create them if they do not exist ([[http://iqbalansari.me/blog/2014/12/07/automatically-create-parent-directories-on-visiting-a-new-file-in-emacs/][Source]])

#+BEGIN_SRC emacs-lisp
(setq confirm-nonexistent-file-or-buffer nil)

(defun create-non-existent-directory ()
  "Check whether a given file's parent directories exist; if they do not, offer to create them."
  (let ((parent-directory (file-name-directory buffer-file-name)))
    (when (and (not (file-exists-p parent-directory))
               (y-or-n-p (format "Directory `%s' does not exist! Create it?" parent-directory)))
      (make-directory parent-directory t))))

(add-to-list 'find-file-not-found-functions #'create-non-existent-directory)
#+END_SRC

** Minibuffer

Sometimes cursor get stuck in minibuffer is annoying

#+BEGIN_SRC emacs-lisp
  (setq minibuffer-prompt-properties
        (quote
         (read-only t point-entered minibuffer-avoid-prompt face minibuffer-prompt)))
#+END_SRC

** Parentheses

Visual indication of matching pairs of parentheses

#+BEGIN_SRC emacs-lisp
(use-package smartparens
  :bind
  (("C-M-f" . sp-forward-sexp)
   ("C-M-b" . sp-backward-sexp)
   ("C-M-d" . sp-down-sexp)
   ("C-M-a" . sp-backward-down-sexp)
   ("C-S-a" . sp-beginning-of-sexp)
   ("C-S-d" . sp-end-of-sexp)
   ("C-M-e" . sp-up-sexp)
   ("C-M-u" . sp-backward-up-sexp)
   ("C-M-t" . sp-transpose-sexp)
   ("C-M-n" . sp-next-sexp)
   ("C-M-p" . sp-previous-sexp)
   ("C-M-k" . sp-kill-sexp)
   ("C-M-w" . sp-copy-sexp)
   ("M-<delete>" . sp-unwrap-sexp)
   ("M-S-<backspace>" . sp-backward-unwrap-sexp)
   ("C-<right>" . sp-forward-slurp-sexp)
   ("C-<left>" . sp-forward-barf-sexp)
   ("C-M-<left>" . sp-backward-slurp-sexp)
   ("C-M-<right>" . sp-backward-barf-sexp)
   ("M-D" . sp-splice-sexp)
   ("C-M-<delete>" . sp-splice-sexp-killing-forward)
   ("C-M-<backspace>" . sp-splice-sexp-killing-backward)
   ("C-M-S-<backspace>" . sp-splice-sexp-killing-around)
   ("C-]" . sp-select-next-thing-exchange)
   ("C-<left_bracket>" . sp-select-previous-thing)
   ("C-M-]" . sp-select-next-thing)
   ("M-F" . sp-forward-symbol)
   ("M-B" . sp-backward-symbol)
   ("H-t" . sp-prefix-tag-object)
   ("H-p" . sp-prefix-pair-object)
   ("H-s c" . sp-convolute-sexp)
   ("H-s a" . sp-absorb-sexp)
   ("H-s e" . sp-emit-sexp)
   ("H-s p" . sp-add-to-previous-sexp)
   ("H-s n" . sp-add-to-next-sexp)
   ("H-s j" . sp-join-sexp)
   ("H-s s" . sp-split-sexp)
   ("M-9" . sp-backward-sexp)
   ("M-0" . sp-forward-sexp))
  :init
  (smartparens-global-mode t)
  (show-smartparens-global-mode t)
  (use-package smartparens-config
    :ensure f)
  ;;; FIXME: Symbol’s value as variable is void: toggle-map
  ;; (bind-key "s" 'smartparens-mode toggle-map)
  (when (is-mac-p)
    (bind-keys ("<s-right>" . sp-forward-slurp-sexp)
               ("<s-left>" . sp-forward-barf-sexp)))
  (sp-with-modes '(markdown-mode gfm-mode)
    (sp-local-pair "*" "*"))
  (sp-with-modes '(org-mode)
    (sp-local-pair "*" "*")
    (sp-local-pair "=" "=")
    (sp-local-pair "/" "/")
    (sp-local-pair "(" ")")
    (sp-local-pair "[" "]"))
  (use-package rainbow-delimiters
    :hook (prog-mode . rainbow-delimiters-mode)))
#+END_SRC

** Whitespace

#+BEGIN_SRC emacs-lisp
(add-hook 'before-save-hook 'whitespace-cleanup)
#+END_SRC

** Zooming
*** Hydra

#+BEGIN_SRC emacs-lisp
(use-package hydra
   :config
   (setq hydra-lv nil))
#+END_SRC

*** Key Binding

#+BEGIN_SRC emacs-lisp
 (defhydra hydra-zoom ()
   "zoom"
   ("+" text-scale-increase "in")
   ("=" text-scale-increase "in")
   ("-" text-scale-decrease "out")
   ("_" text-scale-decrease "out")
   ("0" (text-scale-adjust 0) "reset")
   ("q" nil "quit" :color blue))

 (bind-keys ("C-x C-0" . hydra-zoom/body)
            ("C-x C-=" . hydra-zoom/body)
            ("C-x C--" . hydra-zoom/body)
            ("C-x C-+" . hydra-zoom/body))
#+END_SRC

Temporary work around when hydra zoom doesn't work

#+BEGIN_SRC emacs-lisp
;; (global-set-key (kbd "C-x C-=") 'text-scale-increase)
;; (global-set-key (kbd "C-x C--") 'text-scale-decrease)
#+END_SRC

** Window

Always full screen

#+BEGIN_SRC emacs-lisp
;; (set-frame-parameter nil 'fullscreen 'fullboth)
#+END_SRC

Maximize screen

#+BEGIN_SRC emacs-lisp
(add-to-list 'default-frame-alist '(fullscreen . maximized))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun vsplit-last-buffer ()
  (interactive)
  (split-window-vertically)
  (other-window 1 nil)
  (switch-to-next-buffer))

(defun hsplit-last-buffer ()
  (interactive)
  (split-window-horizontally)
  (other-window 1 nil)
  (switch-to-next-buffer))

(bind-key "C-x 2" 'vsplit-last-buffer)
(bind-key "C-x 3" 'hsplit-last-buffer)
#+END_SRC

** Title of Frame

#+BEGIN_SRC emacs-lisp
(setq frame-title-format '("Orca"))
#+END_SRC

* Security
** TLS

#+BEGIN_SRC emacs-lisp
(setq tls-checktrust t
      gnutls-verify-error t)
;; FIXME:  workaround to fix https not working well with elpa
;; https://www.reddit.com/r/orgmode/comments/cvmjjr/workaround_for_tlsrelated_bad_request_and_package/
(when
  (and
    (>= libgnutls-version 30603)
    (version<= emacs-version "26.2")
  )
(setq gnutls-algorithm-priority "NORMAL:-VERS-TLS1.3"))
#+END_SRC

** Encryption

Force emacs to use its own password prompt ([[https://github.com/mwfogleman/.emacs.d/blob/master/michael.org#encryption][Source]])

#+BEGIN_SRC emacs-lisp
  (setenv "GPG_AGENT_INFO" nil)
#+END_SRC

** Pass

#+BEGIN_SRC emacs-lisp
(use-package pass)
#+END_SRC

* Saving
** Backups
 Store backups and auto-saved files in a fixed location rather in the same directory as the file.

 #+BEGIN_SRC emacs-lisp
 (let ((backup-dir "~/Documents/backups")
       (auto-saves-dir "~/Documents/auto-saves/"))
   (dolist (dir (list backup-dir auto-saves-dir))
     (when (not (file-directory-p dir))
       (make-directory dir t)))
   (setq backup-directory-alist `(("." . ,backup-dir))
         auto-save-file-name-transforms `((".*" ,auto-saves-dir t))
         auto-save-list-file-prefix (concat auto-saves-dir ".saves-")
         tramp-backup-directory-alist `((".*" . ,backup-dir))
         tramp-auto-save-directory auto-saves-dir))

 (setq backup-by-copying t    ; Don't delink hardlinks
       delete-old-versions t  ; Clean up the backups
       version-control t      ; Use version numbers on backups,
       kept-new-versions 5    ; keep some new versions
       kept-old-versions 2)   ; and some old ones, too
 #+END_SRC

** Auto Revert

Revert buffers automatically when underlying files are changed externally. Auto refreshes every 2 seconds. Don't forget to refresh the version control status as well.

#+BEGIN_SRC emacs-lisp
  (use-package autorevert
    :ensure nil
    :hook (after-init . global-auto-revert-mode)
    :config
    (setq
      auto-revert-interval 2
      auto-revert-check-vc-info t
      auto-revert-verbose nil))
#+END_SRC

** Save Place

If you close a buffer, it remembers where you were in the file, so
that when you re-open that file the buffer goes straight to that
place. The configuration of this mode is very simple as of Emacs 25.1.

#+BEGIN_SRC emacs-lisp

(setq-default save-place t)
(setq save-place-file (expand-file-name ".places" user-emacs-directory))

(save-place-mode 1)
#+END_SRC

* Key Bindings
** Lines

Enable line indenting automatically. If needed, you can disable on a mode-by-mode basis.

#+BEGIN_SRC emacs-lisp
(bind-keys ("RET" . newline-and-indent)
           ("C-j" . newline-and-indent))
#+END_SRC

Make C-n insert new lines if the point is at the end of the buffer.

#+BEGIN_SRC emacs-lisp
(setq next-line-add-newlines t)
#+END_SRC
** Scrolling

#+BEGIN_SRC emacs-lisp
;; better scrolling experience
(setq scroll-margin 0
      scroll-conservatively 10000
      scroll-preserve-screen-position t
      auto-window-vscroll nil)
#+END_SRC

There are lots of neat ways of moving around quickly in a
buffer. (Source: [[http://whattheemacsd.com/key-bindings.el-02.html][What the .emacs.d?]])

#+BEGIN_SRC emacs-lisp
(defun super-next-line ()
  (interactive)
  (ignore-errors (next-line 5)))

(defun super-previous-line ()
  (interactive)
  (ignore-errors (previous-line 5)))

(defun super-backward-char ()
  (interactive)
  (ignore-errors (backward-char 5)))

(defun super-forward-char ()
  (interactive)
  (ignore-errors (forward-char 5)))

(bind-keys ("C-S-n" . super-next-line)
           ("C-S-p" . super-previous-line)
           ("C-S-b" . super-backward-char)
           ("C-S-f" . super-forward-char))
#+END_SRC

** backward-kill-line

This binding comes from Emacs Redux.

#+BEGIN_SRC emacs-lisp
  (bind-key "C-<backspace>" (lambda ()
                              (interactive)
                              (kill-line 0)
                              (indent-according-to-mode)))

#+END_SRC

** Cycle Spacing

#+BEGIN_SRC emacs-lisp
  (bind-key "C-x SPC" 'cycle-spacing)
#+END_SRC

** OS X
 #+BEGIN_SRC emacs-lisp
 (when (is-mac-p)
   (setq mac-command-modifier 'meta
         mac-option-modifier 'super
         mac-control-modifier 'control
         ns-function-modifier 'hyper))
 #+END_SRC

#+BEGIN_SRC text :tangle ~/Library/KeyBindings/DefaultKeyBinding.dict
{
/* Keybindings for emacs emulation.  Compiled by Jacob Rus.
 *
 * This is a pretty good set, especially considering that many emacs bindings
 * such as C-o, C-a, C-e, C-k, C-y, C-v, C-f, C-b, C-p, C-n, C-t, and
 * perhaps a few more, are already built into the system.
 *
 * BEWARE:
 * This file uses the Option key as a meta key.  This has the side-effect
 * of overriding Mac OS keybindings for the option key, which generally
 * make common symbols and non-english letters.
 */

    /* Ctrl shortcuts */
    "^l"        = "centerSelectionInVisibleArea:";  /* C-l          Recenter */
    "^/"        = "undo:";                          /* C-/          Undo */
    "^_"        = "undo:";                          /* C-_          Undo */
    "^ "        = "setMark:";                       /* C-Spc        Set mark */
    "^\@"       = "setMark:";                       /* C-@          Set mark */
    "^w"        = "deleteToMark:";                  /* C-w          Delete to mark */


    /* Incremental search. */
    /* Uncomment these lines If Incremental Search IM is installed */
    /*  "^s"        = "ISIM_incrementalSearch:";        /* C-s          Incremental search */
    /*  "^r"        = "ISIM_reverseIncrementalSearch:"; /* C-r          Reverse incremental search */
    /*  "^g"        = "abort:";                         /* C-g          Abort */


    /* Meta shortcuts */
    "~f"        = "moveWordForward:";               /* M-f          Move forward word */
    "~b"        = "moveWordBackward:";              /* M-b          Move backward word */
    "~<"        = "moveToBeginningOfDocument:";     /* M-<          Move to beginning of document */
    "~>"        = "moveToEndOfDocument:";           /* M->          Move to end of document */
    "~v"        = "pageUp:";                        /* M-v          Page Up */
    "~/"        = "complete:";                      /* M-/          Complete */
    "~c"        = ( "capitalizeWord:",              /* M-c          Capitalize */
                    "moveForward:",
                    "moveForward:");
    "~u"        = ( "uppercaseWord:",               /* M-u          Uppercase */
                    "moveForward:",
                    "moveForward:");
    "~l"        = ( "lowercaseWord:",               /* M-l          Lowercase */
                    "moveForward:",
                    "moveForward:");
    "~d"        = "deleteWordForward:";             /* M-d          Delete word forward */
    "^~h"       = "deleteWordBackward:";            /* M-C-h        Delete word backward */
    "~\U007F"   = "deleteWordBackward:";            /* M-Bksp       Delete word backward */
    "~t"        = "transposeWords:";                /* M-t          Transpose words */
    "~\@"       = ( "setMark:",                     /* M-@          Mark word */
                    "moveWordForward:",
                    "swapWithMark");
    "~h"        = ( "setMark:",                     /* M-h          Mark paragraph */
                    "moveToEndOfParagraph:",
                    "swapWithMark");

    /* C-x shortcuts */
    "^x" = {
        "u"     = "undo:";                          /* C-x u        Undo */
        "k"     = "performClose:";                  /* C-x k        Close */
        "^f"    = "openDocument:";                  /* C-x C-f      Open (find file) */
        "^x"    = "swapWithMark:";                  /* C-x C-x      Swap with mark */
        "^m"    = "selectToMark:";                  /* C-x C-m      Select to mark*/
        "^s"    = "saveDocument:";                  /* C-x C-s      Save */
        "^w"    = "saveDocumentAs:";                /* C-x C-w      Save as */
    };

}
#+END_SRC
** which-key

#+BEGIN_SRC emacs-lisp
(use-package which-key
  :diminish which-key-mode
  :defer 1
  :config
  (which-key-mode +1)
  (setq which-key-idle-delay 0.4
        which-key-idle-secondary-delay 0.4))
#+END_SRC

** discover-my-major

#+BEGIN_SRC emacs-lisp
(use-package discover-my-major
  :bind ("C-h C-m" . discover-my-major))
#+END_SRC

** Interaction Log

Interaction Log is like view-lossage (C-h l) or kmacro-edit-macro but
it is live-updating and not tied to macros. It’s useful for when you
type an (awesome? terrible?) Emacs command and want to figure out
which function you used so you can use it again or destroy it
forever. For a long time I was plagued by accidentally hitting
downcase-region and didn’t know what the function was - this would
have been so useful!

#+BEGIN_SRC emacs-lisp
(use-package interaction-log)

(interaction-log-mode +1)

(defun open-interaction-log ()
  (interactive)
  (display-buffer ilog-buffer-name))

(bind-key "C-h C-l" 'open-interaction-log)
#+END_SRC

* Programming
** Path

Define append to path method

#+BEGIN_SRC emacs-lisp
(defun yizhe/append-to-path (path)
  "Add a path both to the $PATH variable and Emacs's path"
  (setenv "PATH" (concat (getenv "PATH") ":" path))
  (add-to-list 'exec-path path))
#+END_SRC

Append path of my programs

#+BEGIN_SRC emacs-lisp
(yizhe/append-to-path "/usr/bin")
(yizhe/append-to-path "/usr/local/bin")
#+END_SRC

** Company Mode

#+BEGIN_SRC emacs-lisp
(use-package company
  :bind (("C-." . company-complete)
         :map company-active-map
         ("C-n" . company-select-next)
         ("C-p" . company-select-previous)
         ("C-d" . company-show-doc-buffer)
         ("<tab>" . company-complete))
  :init
  (global-company-mode 1)
  :config
  (setq company-show-numbers t
        company-tooltip-align-annotations t)

  (let ((map company-active-map))
    (mapc
     (lambda (x)
       (define-key map (format "%d" x) 'ora-company-number))
     (number-sequence 0 9))
    (define-key map " " (lambda ()
                          (interactive)
                          (company-abort)
                          (self-insert-command 1)))
    (define-key map (kbd "<return>") nil))

  (defun ora-company-number ()
    "Forward to `company-complete-number'.

Unless the number is potentially part of the candidate.
In that case, insert the number."
    (interactive)
    (let* ((k (this-command-keys))
           (re (concat "^" company-prefix k)))
      (if (cl-find-if (lambda (s) (string-match re s))
                      company-candidates)
          (self-insert-command 1)
        (company-complete-number (string-to-number k))))))
#+END_SRC

** Shell

Indent with 2 spaces.

#+BEGIN_SRC emacs-lisp
(add-hook 'sh-mode-hook
          (lambda ()
            (setq sh-basic-offset 2
                  sh-indentation 2)))

(setq-default explicit-shell-file-name "bash")
#+END_SRC

** Eshell

Testing this out

#+BEGIN_SRC emacs-lisp
  (use-package eshell
    :bind (("<f1>" . eshell))
    :hook ((eshell-mode . with-editor-export-editor)
           (eshell-mode . setup-company-eshell-autosuggest))
    :init
    (setq eshell-banner-message "")

    (defun new-eshell ()
      (interactive)
      (eshell 'true))

    (use-package esh-autosuggest
      :init
      (defun setup-company-eshell-autosuggest ()
        (with-eval-after-load 'company
          (setq-local company-backends '(esh-autosuggest))
          (setq-local company-frontends '(company-preview-frontend))))))
#+END_SRC

*** Some eshell functions

[[https://justin.abrah.ms/dotfiles/emacs.html][source]]

#+BEGIN_SRC emacs-lisp
(defun eshell/extract (file)
  (eshell-command-result (concat (if-string-match-then-result
                                  file
                                  '((".*\.tar.bz2" "tar xjf")
                                    (".*\.tar.gz" "tar xzf")
                                    (".*\.bz2" "bunzip2")
                                    (".*\.rar" "unrar x")
                                    (".*\.gz" "gunzip")
                                    (".*\.tar" "tar xf")
                                    (".*\.tbz2" "tar xjf")
                                    (".*\.tgz" "tar xzf")
                                    (".*\.zip" "unzip")
                                    (".*\.jar" "unzip")
                                    (".*\.Z" "uncompress")
                                    (".*" "echo 'Could not extract the requested file:'")))
                                 " " file)))

(defun eshell/clear ()
  "clear the eshell buffer."
  (interactive)
  (let ((inhibit-read-only t))
    (erase-buffer)))
#+END_SRC

** Scala

=scala-mode= and =sbt-mode= needs to be installed

#+BEGIN_SRC emacs-lisp
  (use-package sbt-mode
    :pin melpa
    :commands sbt-start sbt-command)

  (use-package scala-mode
    :pin melpa
    :interpreter ("scala" . scala-mode))
#+END_SRC

And mute the start-up message

#+BEGIN_SRC emacs-lisp
(use-package ensime
  :init
  (put 'ensime-auto-generate-config 'safe-local-variable #'booleanp)
  (setq
    ensime-startup-snapshot-notification nil
    ensime-startup-notification nil))

#+END_SRC
** R

Enable ess

#+BEGIN_SRC emacs-lisp
 (use-package ess
  :ensure t
  :init (require 'ess-site))
#+END_SRC

#+BEGIN_SRC
(setq ess-Rf-ont-lock-keywords
    '((ess-R-fl-keyword:modifiers . t)
     (ess-R-fl-keyword:fun-defs . t)
     (ess-R-fl-keyword:keywords . t)
     (ess-R-fl-keyword:assign-ops)
     (ess-R-fl-keyword:constants . t)
     (ess-fl-keyword:fun-calls . t)
     (ess-fl-keyword:numbers)
     (ess-fl-keyword:operators)
     (ess-fl-keyword:delimiters)
     (ess-fl-keyword:=)
     (ess-R-fl-keyword:F&T)
     (ess-R-fl-keyword:%op%)))

(add-hook 'ess-mode-hook 'turn-on-pretty-mode)
#+END_SRC

Activate company mode with ESS

#+BEGIN_SRC emacs-lisp
        (setq ess-use-company t
                                company-selectionw-rap-around t
                                company-tooltip-align-annotations t
                                company-idle-delay 0.36
                                company-show-numbers t
                                company-tooltip-flip-when-above t
                                company-minimum-prefix-length 2
                                company-tooltip-limit 10)

#+END_SRC

Display quick help

#+BEGIN_SRC emacs-lisp
(define-key company-active-map (kbd "M-h") 'company-show-doc-buffer)
#+END_SRC

Completion keys

#+BEGIN_SRC emacs-lisp
(define-key company-active-map [return] nil)
(define-key company-active-map [tab] 'company-complete-common)
(define-key company-active-map (kbd "TAB") 'company-complete-common)
(define-key company-active-map (kbd "M-TAB") 'company-complete-selection)
#+End_Src

Bind =M-,= as next in auto-complete, =M-k= as previous.

#+BEGIN_SRC emacs-lisp
 (define-key company-active-map (kbd "M-n") nil)
 (define-key company-active-map (kbd "M-p") nil)
 (define-key company-active-map (kbd "M-,") 'company-select-next)
 (define-key company-active-map (kbd "M-k") 'company-select-previous)
#+END_SRC

An example is like:

#+BEGIN_SRC R
         library(ggplot2)

         ggplot(mpg, aes(displ, hwy, Colour = class)) +
                         geom_point() +
                         geom_abline
#+END_SRC

When use R with =org-mode=, Don't need to double check before evaluate with =C-c C-c=

#+BEGIN_SRC emacs-lisp
 (setq org-confirm-babel-evaluate nil)
#+END_SRC

Enable graphical output

#+BEGIN_SRC emacs-lisp
 (add-hook 'org-babel-after-execute-hook 'org-display-inline-images)
 (add-hook 'org-mode-hook 'org-display-inline-images)
#+END_SRC

Some inline example SRC_R[:exports results]{round(pi, 2)}

** Python
*** Config

Add =/opt/anaconda/bin= to load path.

#+BEGIN_SRC emacs-lisp
(when (is-linux-p) (yizhe/append-to-path "/opt/anaconda/bin"))
(when (is-mac-p) (yizhe/append-to-path "~/.pyenv/shims/python"))
#+END_SRC

Configure my coda environments

#+BEGIN_SRC emacs-lisp
; where to look for environments
(when (is-linux-p)(setenv "WORKON_HOME" "/home/yizhe/.conda/envs"))
(when (is-mac-p)(setenv "WORKON_HOME" "~/.local/share/virtualenvs"))

(use-package pyvenv
        :init
        (pyvenv-mode 1)
        (pyvenv-tracking-mode 1))
#+END_SRC

Configure python mode

#+BEGIN_SRC emacs-lisp
;; enable elpy
(use-package python
  :defer t
  :mode ("\\.py\\'" . python-mode)
  :interpreter ("python" . python-mode)
  :init
  (setq-default indent-tabs-mode nil)
  :config
  (setq python-indent-offset 4)
  (use-package smartparens
    :init
    (add-hook 'python-mode-hook 'smartparens-mode))
  (use-package color-identifiers-mode
    :init
    (add-hook 'python-mode-hook 'color-identifiers-mode)))
#+END_SRC

Use =elpy=, it is nice!

#+BEGIN_SRC emacs-lisp
(use-package elpy
  :init (add-hook 'python-mode-hook 'elpy-enable))
#+END_SRC

Python indents

#+BEGIN_SRC emacs-lisp
(setq python-indent-guess-indent-offset t)
(setq python-indent-guess-indent-offset-verbose nil)
#+END_SRC

Have been getting this: Warning (python): Your
‘python-shell-interpreter’ doesn’t seem to support readline, yet
‘python-shell-completion-native’ was t and "ipython" is not part of
the ‘python-shell-completion-native-disabled-interpreters’
list. Native completions have been disabled locally.

#+BEGIN_SRC emacs-lisp
(setq python-shell-completion-native-enable nil)
#+END_SRC

Use =ipython= interpreter with elpy

#+BEGIN_SRC emacs-lisp
;; ipython interpreter
(setq python-shell-interpreter "ipython"
      python-shell-interpreter-args "-i --simple-prompt")
#+END_SRC

Format code according to =PEP8= when save:

#+BEGIN_SRC emacs-lisp
(use-package py-autopep8
:init
(add-hook 'elpy-mode-hook 'py-autopep8-enable-on-save))
#+END_SRC

=elpy= fix indentation

#+BEGIN_SRC emacs-lisp
(use-package elpy
  :ensure t
  :commands elpy-enable
  :init (with-eval-after-load 'python (elpy-enable))

  :config
  (electric-indent-local-mode -1)
  (delete 'elpy-module-highlight-indentation elpy-modules)
  (delete 'elpy-module-flymake elpy-modules)

  (defun ha/elpy-goto-definition ()
    (interactive)
    (condition-case err
        (elpy-goto-definition)
      ('error (xref-find-definitions (symbol-name (symbol-at-point))))))

  :bind (:map elpy-mode-map ([remap elpy-goto-definition] .
                             ha/elpy-goto-definition)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(add-hook 'elpy-mode-hook
            (lambda ()
                    (setq-default indent-tabs-mode t)
                    (setq-default tab-width 2)
                    (setq-default py-indent-tabs-mode t)
            (add-to-list 'write-file-functions 'delete-trailing-whitespace)))
#+END_SRC

=Jedi= for auto-completion

#+BEGIN_SRC emacs-lisp
(use-package jedi
  :config
  (use-package company-jedi
    :init
    (add-hook 'python-mode-hook (lambda () (add-to-list 'company-backends 'company-jedi)))
    (setq company-jedi-python-bin "python")))
#+END_SRC

*** Example of use

**** plots

#+begin_src python :results file
import matplotlib, numpy
matplotlib.use('Agg')
import matplotlib.pyplot as plt
fig=plt.figure(figsize=(4,2))
x=numpy.linspace(-15,15)
plt.plot(numpy.sin(x)/x)
fig.tight_layout()
plt.savefig('python-matplot-fig.png')
return 'python-matplot-fig.png' # return filename to org-mode
#+end_src

#+RESULTS:
[[file:python-matplot-fig.png]]

**** inline source code

#+begin_src python :session sess_calc :exports code :results none
a = 5 + 5
b = a + 5
#+end_src

Another inline example: the result of the calculation is src_python[:session calc]{a}

- test with result in a list: src_python[:session sess_calc]{a}
  + src_python[:session sess_calc]{a} vs src_python[:session sess_calc]{b}
  + 1 + 1 = src_python[:exports code]{ return 1 + 1 }

Another example using value raw option ([[https://orgmode.org/manual/results.html][link]])

#+begin_src python :session calc :exports code :results values raw
a = 5 + 5
b = a-1
ares = '#+MACRO: a '+ str(a)
bres = '#+MACRO: b '+ str(b)
ares + '\n' + bres
#+end_src

#+RESULTS:
#+MACRO: a 10
#+MACRO: b 9

The result is still {{{a}}} and b is {{{b}}}. The key is source code
block needs to evaluated first before export.

**** caching

#+name: cachedFunction
#+BEGIN_SRC python :cache yes
x = 18
return x
#+END_SRC

#+name: uncachedFunction
#+BEGIN_SRC python :var x=cachedFunction
return int(x)
#+END_SRC

Now any calls to call_uncachedFunction() will get the cached value from cachedFunction.

** Julia
*** With OSX
#+BEGIN_SRC emacs-lisp
  (when (is-mac-p)
    (yizhe/append-to-path "/Applications/Julia-1.0.app/Contents/Resources/julia/bin"))
#+END_SRC

*** Julia Repl

#+BEGIN_SRC emacs-lisp
(use-package julia-repl)
#+END_SRC

*** ob-julia

#+BEGIN_SRC shell
curl -o ~/.emacs.d/resources/ob-julia.el https://code.orgmode.org/bzg/org-mode/raw/master/contrib/lisp/ob-julia.el
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package ob-julia
    :load-path "~/.emacs.d/resources")
#+END_SRC

** Regexp

Regexes are great. Not everyone knows them, and most user interfaces
don’t expose them, but I think most people who use computers could use
them. Luckily, Emacs is great about this. It’s easier to use them if
you have good tools for noticing if your regular expressions match
input.

*** Build Regexes

#+BEGIN_SRC emacs-lisp
 (use-package re-builder
   :bind (("C-c R" . re-builder))
   :config
   (setq reb-re-syntax 'string))
#+END_SRC

*** Replace Strings with Regexes
#+BEGIN_SRC emacs-lisp
 (use-package visual-regexp
     :bind (("M-5" . vr/replace)
            ("M-%" . vr/query-replace)))
#+END_SRC
** Emacs Lisp
*** Elisp-Slime-Nav
#+BEGIN_SRC emacs-lisp
(use-package elisp-slime-nav
  :init
  (dolist (hook '(emacs-lisp-mode-hook ielm-mode-hook))
    (add-hook hook 'elisp-slime-nav-mode)))
#+END_SRC

*** Eldoc

When in emacs-lisp-mode, display the argument list for the current
function.

#+BEGIN_SRC emacs-lisp
(autoload 'turn-on-eldoc-mode "eldoc" nil t)
(add-hook 'emacs-lisp-mode-hook 'eldoc-mode)
(add-hook 'lisp-interaction-mode-hook 'eldoc-mode)
(add-hook 'ielm-mode-hook 'eldoc-mode)
(add-hook 'cider-mode-hook 'eldoc-mode)
#+END_SRC

** Git
*** magit

#+BEGIN_SRC emacs-lisp
(use-package magit
  :bind (("C-x g" . magit-status)
         ("C-c g" . magit-status)
         :map magit-status-mode-map
         ("TAB" . magit-section-toggle)
         ("<C-tab>" . magit-section-cycle)
         :map magit-branch-section-map
         ("RET" . magit-checkout))
  :config
  (add-hook 'after-save-hook 'magit-after-save-refresh-status)
  (setq magit-use-overlays nil
        magit-section-visibility-indicator nil
        magit-completing-read-function 'ivy-completing-read
        magit-push-always-verify nil
        magit-repository-directories '("~/src/"))
  (use-package git-timemachine
    :bind (("C-x v t" . git-timemachine)))
  (use-package git-link
    :bind (("C-x v L" . git-link))
    :init
    (setq git-link-open-in-browser t))
  (use-package pcmpl-git)
  (defun visit-pull-request-url ()
    "Visit the current branch's PR on Github."
    (interactive)
    (browse-url
     (format "https://github.com/%s/pull/new/%s"
             (replace-regexp-in-string
              "\\`.+github\\.com:\\(.+\\)\\.git\\'" "\\1"
              (magit-get "remote"
                         (magit-get-remote)
                         "url"))
             (cdr (magit-get-remote-branch)))))

  (bind-key "v" 'visit-pull-request-url magit-mode-map)

  ;; Do Not Show Recent Commits in status window
  ;; https://github.com/magit/magit/issues/3230#issuecomment-339900039
  (magit-add-section-hook 'magit-status-sections-hook
                          'magit-insert-unpushed-to-upstream
                          'magit-insert-unpushed-to-upstream-or-recent
                          'replace))
#+END_SRC

*** Git Auto Commit Mode

#+BEGIN_SRC emacs-lisp
(use-package git-auto-commit-mode
  :delight)
#+END_SRC

** SQL

Use =sql-mode= for =.hql= file type

#+BEGIN_SRC emacs-lisp
;; I want .hql and .q files to use sql-mode
(defun my-sql-customisations ()
  "sql-mode customisations that must be done after sql-mode loads"
  (add-to-list 'same-window-buffer-names "*SQL*"))

(use-package sql
  :config
  (add-to-list 'auto-mode-alist '("\\.hql\\'" . sql-mode))
  (autoload 'sql-mode "sql-mode" "SQL editing mode." t)
  (setq sql-mode-hook 'my-sql-customisations))
#+END_SRC

Indentation

#+BEGIN_SRC emacs-lisp
(use-package sql-indent
  :config
(add-hook 'sql-mode-hook 'sqlind-minor-mode))
#+END_SRC

Line truncates

#+BEGIN_SRC emacs-lisp
(add-hook 'sql-interactive-mode-hook
          (lambda ()
            (toggle-truncate-lines t)))
#+END_SRC

upper case SQL keywords from [[https://www.emacswiki.org/emacs/SqlMode][here]]

#+BEGIN_SRC emacs-lisp
(defun sql-upcase-keywords ()
  (interactive)
  (save-excursion
    (dolist (keywords sql-mode-postgres-font-lock-keywords)
      (goto-char (point-min))
      (while (re-search-forward (car keywords) nil t)
        (goto-char (+ 1 (match-beginning 0)))
        (when (eql font-lock-keyword-face (face-at-point))
          (backward-char)
          (upcase-word 1)
          (forward-char))))))
#+END_SRC

** Latex

#+BEGIN_SRC emacs-lisp
(when (is-mac-p) (yizhe/append-to-path "/Library/TeX/texbin/"))
#+END_SRC

** graphviz
#+BEGIN_SRC emacs-lisp
(use-package graphviz-dot-mode)
#+END_SRC
** tramp

#+BEGIN_SRC emacs-lisp
(setq tramp-default-method "sshx")
(setq tramp-auto-save-directory "~/Documents/auto-saves")
(setq tramp-shell-prompt-pattern "^[^$>\n]*[#$%>] *\\(\[[0-9;]*[a-zA-Z] *\\)*")
#+END_SRC
** json

#+BEGIN_SRC emacs-lisp
(use-package json-mode)
#+END_SRC

* Writing
** =org-mode=

[[http://xahlee.info/comp/unicode_index.html][Unicode!]]

#+BEGIN_SRC emacs-lisp
(use-package org
  :bind (("C-c c" . org-capture)
         ("C-c a" . org-agenda)
         ("C-c b" . org-iswitchb)
         ("C-c M-k" . org-cut-subtree)
         :map org-mode-map
         ("C-c >" . org-time-stamp-inactive))
  :custom-face
  (variable-pitch ((t (:family "ETBembo"))))
  (org-done ((t (:strike-through t ))))
  (org-headline-done ((t ( :strike-through t))))
  (org-image-actual-width '(600))
  :init
  (setq default-major-mode 'org-mode
        org-blank-before-new-entry '((heading . always) (plain-list-item . nil))
        org-confirm-babel-evaluate nil
        org-completion-use-ido t
        org-default-priority ?B
        org-default-notes-file (concat org-directory "index.org")
        org-directory "~/Documents/yizhe/"
        org-agenda-files (list org-directory)
        org-ellipsis "⤵" ;; foldings symbol
        org-expiry-inactive-timestamps t
        org-fontify-whole-heading-line t
        org-fontify-done-headline t
        org-fontify-quote-and-verse-blocks t
        org-format-latex-options (plist-put org-format-latex-options :scale 1.5)
        org-footnote-auto-adjust t
        org-footnote-auto-label t
        org-file-apps
        '((auto-mode . emacs)
          ("\\.mm\\'" . default)
          ("\\.x?html?\\'" . "firefox %s")
          ("\\.pdf\\'" . "open %s"))
        org-goto-max-level 10
        org-goto-interface 'outline-path-completion
        org-hide-emphasis-markers t ;; show actually italicized text instead of /italicized text/
        org-image-actual-width '(300)
        org-imenu-depth 5
        org-log-done t
        org-startup-indented t
        org-startup-truncated nil
        org-startup-with-inline-images t
        org-show-notification-handler 'message
        org-special-ctrl-a/e t
        org-special-ctrl-k t
        org-src-preserve-indentation t
        org-src-fontify-natively t
        org-src-window-setup 'current-window
        org-tags-column 80
        org-todo-keywords '((sequence "TODO(t)" "STARTED(s)" "FOLLOWUP(f)" "WAITING(w)" "|" "DONE(x!)" "CANCELLED(c)"))
        org-outline-path-complete-in-steps nil
        org-lowest-priority ?C
        org-yank-adjusted-subtrees t
        org-pretty-entities t
        org-use-sub-superscripts '{} ;; underscores, etc needs to be wraped as a_{underscore}
        )

  (add-to-list 'org-global-properties
               '("Effort_ALL". "0:05 0:15 0:30 1:00 2:00 3:00 4:00"))

  (add-hook 'org-mode-hook 'flyspell-mode)

  (add-hook 'org-mode-hook
            '(lambda ()
               "Beautify Org Checkbox Symbol"
               (push '("TODO"  . ?▲) prettify-symbols-alist)
               (push '("STARTED"  . ?♫) prettify-symbols-alist)
               (push '("FOLLOWUP"  . ??) prettify-symbols-alist)
               (push '("WAITING" . ?⁕) prettify-symbols-alist)
               (push '("DONE"  . ?✓) prettify-symbols-alist)
               (push '("CANCELLED"  . ?✘) prettify-symbols-alist)
               (prettify-symbols-mode)
               ))
  )
#+END_SRC

** Capture

Configure my capture template!

When I do the following task, I use =C-c c= to capture it, including:
- recording a task
- a meeting
- do a journal entry of the day

#+BEGIN_SRC emacs-lisp
(setq org-capture-templates
      (quote (("t" "Task" entry (file "~/Documents/yizhe/index.org")
               "* TODO %?\nSCHEDULED: %(org-insert-time-stamp (org-read-date nil t \"today\"))\n %^{Effort}p \n")
              ("m" "Meeting" entry (file "~/Documents/yizhe/meeting.org")
               "* TODO Meet with %? \nSCHEDULED: %(org-insert-time-stamp (org-read-date nil t \"today\"))")
              ("j" "Journal" entry (file+datetree "~/Documents/yizhe/logbook.org")
               "* %?\n%U\n" :clock-in t :clock-resume t))))
#+END_SRC

** Refile

#+BEGIN_SRC emacs-lisp
(setq org-refile-targets '((org-agenda-files . (:maxlevel . 4)))
      ;; org-refile-use-cache t
      org-refile-use-outline-path t)

#+END_SRC

Exclude completed tasks from refile targets, from Michael Englehorn’s Emacs Configuration.

#+BEGIN_SRC emacs-lisp
(defun verify-refile-target
    ()
  "Exclude todo keywords with a done state from refile targets"
  (not (member (nth 2 (org-heading-components)) org-done-keywords)))

(setq org-refile-target-verify-function 'verify-refile-target)
#+END_SRC

** =org-agenda=

*** Configuration

#+begin_src emacs-lisp
(setq
 ;; stop preparing agenda buffers on startup
 org-agenda-inhibit-startup t

 ;; blocks
 org-agenda-block-separator nil
 org-agenda-compact-blocks t
 org-agenda-show-future-repeats nil
 org-agenda-start-on-weekday nil

 ;; skips
 org-agenda-skip-archived-trees t
 org-agenda-skip-deadline-if-done t
 org-agenda-skip-scheduled-if-done t

 org-agenda-window-setup 'current-window

 ;; hit r to rebuild agenda
 org-agenda-sticky t

 org-agenda-tags-column org-tags-column
 org-deadline-warning-days 5
 org-agenda-with-colors t
 org-agenda-sorting-strategy
 (quote
  ((agenda deadline-up priority-down)
   (todo priority-down category-keep)
   (tags priority-down category-keep)
   (search category-keep)))
 org-agenda-time-grid
 '((daily today require-timed)
   ()
   "......"
   ".................."))
#+end_src

*** =org-super-agenda=

#+BEGIN_SRC emacs-lisp
(use-package org-super-agenda
  :config (org-super-agenda-mode))
#+END_SRC

*** =org-super-agenda-groups=

#+BEGIN_SRC emacs-lisp
(setq org-agenda-custom-commands
      '(("z" "Super view"
         ((agenda "" ((org-agenda-span 'day)
                      (org-super-agenda-groups
                       '((:name "Today"
                                :time-grid t
                                :habit t
                                :date today
                                :scheduled today)
                         (:name "Important"
                                :date today
                                :scheduled today
                                :priority "A")))))

          (alltodo "" ((org-agenda-overriding-header "")
                       (org-super-agenda-groups
                        '((:auto-group t)
                          (:name "Important"
                                 :priority "A")
                          (:name "Quick Picks"
                                 :effort< "0:30")
                          (:name "Due Soon"
                                 :deadline future)
                          (:name "Overdue"
                                 :deadline past)
                          (:name "To read"
                                 :tag "read")
(:name "To write"
:tag "write")
                          (:name "Follow up"
                                 :todo "FOLLOWUP")))))))))
#+END_SRC

*** Clocking

Use clocking to track time spend on tasks

**** Configuration

#+BEGIN_SRC emacs-lisp
  (setq org-log-done 'time
        org-clock-idle-time nil
        org-clock-continuously nil
        org-clock-persist t
        org-clock-in-switch-to-state "STARTED"
        org-clock-in-resume nil
        org-clock-report-include-clocking-task t
        org-clock-out-remove-zero-time-clocks t
        ;; Too many clock entries clutter up a heading
        org-log-into-drawer t
        org-clock-into-drawer 1)
#+END_SRC
**** Remove Empty Logbook Drawers

Remove empty LOGBOOK drawers on clock out, from [[https://michael.englehorn.com/config.html][Michael Englehorn's
Emacs Configuration]]. This [[https://stackoverflow.com/questions/21767471/org-capture-and-time-clocking-misbehaving#21797427][Stack Overflow post]] shows the fix to the bug
in the original function (remove the "LOGBOOK" specification).

#+BEGIN_SRC emacs-lisp
  (defun bh/remove-empty-drawer-on-clock-out ()
    (interactive)
    (save-excursion
      (beginning-of-line 0)
      (org-remove-empty-drawer-at (point))))

  (add-hook 'org-clock-out-hook 'bh/remove-empty-drawer-on-clock-out 'append)
#+END_SRC

**** Key Bindings

However, there are a *lot* of commands for clocking; this is a perfect instance for a Hydra.

#+BEGIN_SRC emacs-lisp
  (defhydra hydra-org-clock (:color blue :hint nil)
    "
  Clock   In/out^     ^Edit^   ^Summary     (_?_)
  -----------------------------------------
          _i_n         _e_dit   _g_oto entry
          _c_ontinue   _q_uit   _d_isplay
          _o_ut        ^ ^      _r_eport
        "
    ("i" org-clock-in)
    ("o" org-clock-out)
    ("c" org-clock-in-last)
    ("e" org-clock-modify-effort-estimate)
    ("q" org-clock-cancel)
    ("g" org-clock-goto)
    ("d" org-clock-display)
    ("r" org-clock-report)
    ("?" (org-info "Clocking commands")))

  (defhydra hydra-org-agenda-clock (:color blue :hint nil)
    "
  Clock   In/out^
  -----------------------------------------
          _i_n
          _g_oto entry
          _o_ut
          _q_uit
        "
    ("i" org-agenda-clock-in)
    ("o" org-agenda-clock-out)
    ("q" org-agenda-clock-cancel)
    ("g" org-agenda-clock-goto))

  (bind-keys ("C-c w" . hydra-org-clock/body)
             :map org-agenda-mode-map
             ("C-c w" . hydra-org-agenda-clock/body))
#+END_SRC

*** Easy Bind To Open Todos

#+begin_src emacs-lisp
(defun open-todo-file ()
  (interactive)
  (find-file "~/Documents/yizhe/index.org"))

(bind-key "C-c t" 'open-todo-file)
#+end_src

*** Search

#+BEGIN_SRC emacs-lisp

(defun the-the ()
  "Search forward for for a duplicated word."
  (interactive)
  (message "Searching for for duplicated words ...")
  (push-mark)
  ;; This regexp is not perfect
  ;; but is fairly good over all:
  (if (re-search-forward
       "\\b\\([^@ \n\t]+\\)[ \n\t]+\\1\\b" nil 'move)
      (message "Found duplicated word.")
    (message "End of buffer")))

;; Bind 'the-the' to  C-c \
(bind-key "C-c \\" 'the-the)

#+END_SRC


*** COMMENT old-org-agenda

**** Custom Agendas
Here are some hand-made agenda files.

#+begin_src emacs-lisp
(defun org-buffer-todo ()
  (interactive)
  "Creates a todo-list for the current buffer. Equivalent to the sequence: org-agenda, < (restrict to current buffer), t (todo-list)."
  (progn
    (org-agenda-set-restriction-lock 'file)
    (org-todo-list)))

(defun org-buffer-agenda ()
  (interactive)
  "Creates an agenda for the current buffer. Equivalent to the sequence: org-agenda, < (restrict to current buffer), a (agenda-list)."
  (progn
    (org-agenda-set-restriction-lock 'file)
    (org-agenda-list)))

(defun org-buffer-day-agenda ()
  (interactive)
  "Creates an agenda for the current buffer. Equivalent to the sequence: org-agenda, < (restrict to current buffer), a (agenda-list), d (org-agenda-day-view)."
  (progn
    (org-agenda-set-restriction-lock 'file)
    (org-agenda-list)
    (org-agenda-day-view))) ;; Maybe I should try writing a Emacs Lisp macro for this kind of thing!

(bind-key "y" 'org-agenda-todo-yesterday org-agenda-mode-map)
#+end_src

**** Unscheduled Tasks

#+begin_src emacs-lisp
(add-to-list 'org-agenda-custom-commands
             '("u" "Unscheduled TODOs"
               ((todo ""
                      ((org-agenda-overriding-header "\nUnscheduled TODO")
                       (org-agenda-skip-function
                        '(org-agenda-skip-entry-if
                          'timestamp 'todo '("DONE" "CANCELLED" "MAYBE" "WAITING" "SOMEDAY"))))))) t)
#+end_src

** =org-bullets=

#+BEGIN_SRC emacs-lisp
  (use-package org-bullets
    :init
    :config
    (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))
#+END_SRC

** =org-modules=

 #+BEGIN_SRC emacs-lisp
(require 'org-install)
;; FIXME: workaround
;; https://github.com/syl20bnr/spacemacs/issues/11798
(when (version<= "9.2" (org-version))
  (require 'org-tempo))

(setq org-modules '(org-habit org-info))
(org-load-modules-maybe t)
 #+END_SRC

** =org-habits=

#+begin_src emacs-lisp
(setq org-habit-graph-column 48)
(setq org-habit-show-habits-only-for-today t)

(defun org-make-habit ()
  (interactive)
  (org-set-property "STYLE" "habit"))
#+end_src

A habit has a =SCHEDULE= tag with a repeat specification like =.+=, =++=, or
=+=. A =STYLE= property set to value habit.

For scheduling:

=.+2d/4d= means:

- Repeat as frequently as every two days, but
- Never less frequently than every four days, and
- When completed, start counting again from today.

=++=  means:

 from the last date completed, count as many 2-day intervals as
 necessary to find a date in the future. This is useful if you want
 something to always fall on the same days of the week

or plain =+= repeat, which is unusual for a habit, because if you fall
quite behind you will need to complete the task as many times as it
takes for the next occurrence to get into the future. This would be
useful for something like paying your rent where you cannot skip any
instances, but that isn’t really a habit.

** =org-cliplink=

A simple command that takes a URL from the clipboard and inserts an
org-mode link with a title of a page found by the URL into the current
buffer.

#+BEGIN_SRC emacs-lisp
(use-package org-cliplink
  :bind ("C-x p i" . org-cliplink))
#+END_SRC

** =org-babel=

Source code that =org-babel= wants to evaluate

#+BEGIN_SRC emacs-lisp
(org-babel-do-load-languages
 'org-babel-load-languages
 '((emacs-lisp . t)
   (R . t)
   (python . t)
   (shell . t)
   (latex . t)
   (julia . t)
   (dot . t)
   (sql . t)))
#+END_SRC

Tangle the source block under cursor ([[https://stackoverflow.com/a/39628921][source]])

#+BEGIN_SRC emacs-lisp
(defun org-babel-tangle-block()
  (interactive)
  (let ((current-prefix-arg '(4)))
     (call-interactively 'org-babel-tangle)
))

(eval-after-load "org"
  '(progn
     (define-key org-mode-map (kbd "C-c b") 'org-babel-tangle-block)
))
#+END_SRC

** =toc-org=

#+begin_src emacs-lisp
(use-package toc-org
    :init
    (add-hook 'org-mode-hook 'toc-org-mode))
#+end_src

** =org-ref=

Configure synced drive path

#+BEGIN_SRC emacs-lisp
(when (is-mac-p)
  (setq keybase-ref "/Volumes/Keybase\ (yizhx)/private/yizhe/references/"))

(when (is-linux-p)
  (setq keybase-ref "/keybase/private/yizhe/references/"))
#+END_SRC

#+begin_src emacs-lisp
(defun my/org-ref-open-pdf-at-point ()
  "Open the pdf for bibtex key under point if it exists."
  (interactive)
  (let* ((results (org-ref-get-bibtex-key-and-file))
         (key (car results))
         (pdf-file (funcall org-ref-get-pdf-filename-function key)))
    (if (file-exists-p pdf-file)
    (funcall bibtex-completion-pdf-open-function (car (bibtex-completion-find-pdf key)))
      (message "No PDF found for %s" key))))

(setq org-ref-open-pdf-function 'my/org-ref-open-pdf-at-point)
(use-package org-ref
  :init
  ;; setup org-ref
  (setq org-ref-default-bibliography "~/Documents/megrez/library.bib"
        org-ref-bibliography-notes "~/Documents/megrez/note.org"
        org-ref-pdf-directory keybase-ref
        org-ref-open-pdf-function 'my/org-ref-open-pdf-at-point))
#+end_src

** =org-noter=

Use org-noter

#+BEGIN_SRC emacs-lisp
(use-package org-noter
  :after org
  :config
  (setq org-noter-default-notes-file-names '("index.org")
        org-noter-notes-search-path '("~/Documents/yizhe")
        org-noter-separate-notes-from-heading t))
#+END_SRC

On smaller screen, change the split

#+BEGIN_SRC emacs-lisp
(when (is-mac-p)
  (setq org-noter-set-doc-split-fraction 0.7))
#+END_SRC

Combine to use with org-ref, [[https://write.as/dani/notes-on-org-noter][source]]

#+BEGIN_SRC emacs-lisp
(defun org-ref-noter-at-point ()
      "Open the pdf for bibtex key under point if it exists."
      (interactive)
      (let* ((results (org-ref-get-bibtex-key-and-file))
             (key (car results))
             (pdf-file (funcall org-ref-get-pdf-filename-function key)))
        (if (file-exists-p pdf-file)
            (progn
              (find-file-other-window pdf-file)
              (org-noter))
          (message "no pdf found for %s" key))))

(add-to-list 'org-ref-helm-user-candidates
             '("Org-Noter notes" . org-ref-noter-at-point))
#+END_SRC

** =pdf-tools=

Configure paths stuff for pdf-tools

#+BEGIN_SRC emacs-lisp
;; appending a new path to existing path
(when (is-mac-p)
  (setenv "PKG_CONFIG_PATH"
          (concat
           "/usr/local/Cellar/zlib/1.2.8/lib/pkgconfig" ":"
           "/usr/local/opt/libffi/lib/pkgconfig" ":"
           "/usr/local/lib/pkgconfig" ":"
           "/opt/X11/lib/pkgconfig" ":"
           (getenv "PKG_CONFIG_PATH")
           )))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package pdf-tools
  :ensure t
  :config
  (custom-set-variables
    '(pdf-tools-handle-upgrades nil)) ; Use brew upgrade pdf-tools instead.
  (setq pdf-info-epdfinfo-program "/usr/local/bin/epdfinfo"))
(pdf-tools-install)
#+END_SRC

** =ox-hugo=

#+BEGIN_SRC emacs-lisp
(use-package ox-hugo
  :after ox)
#+END_SRC


** examples
*** plain list
**** Lord of the Rings
   My favorite scenes are (in this order)
   1. The attack of the Rohirrim
   2. Eowyn's fight with the witch king
      + this was already my favorite scene in the book
      + I really like Miranda Otto.
   3. Peter Jackson being shot by Legolas
      - on DVD only
      He makes a really funny face when it happens.
   But in the end, no individual scenes matter but the film as a whole.
   Important actors in this film are:
   - Elijah Wood :: He plays Frodo
   - Sean Astin :: He plays Sam, Frodo's friend.  I still remember
     him very well from his role as Mikey Walsh in The Goonies.

*** table

Read doc at [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Text-Based-Tables.html][here]]

Bound to table mode: =C-c ~=

+---------+---------+---------+
| Header1 | Header2 | Header3 |
+---------+---------+---------+
| Merged  | Text1   | Text2   |
| text    +---------+---------+
| here    | Text3   | Text4   |
+---------+---------+---------+

+-----------------+--------------------------------+-----------------+
|     Command     |          Description           |   Key Binding   |
+-----------------+--------------------------------+-----------------+
|  forward-char   |Move point right N characters   |       C-f       |
|                 |(left if N is negative).        |                 |
|                 |                                |                 |
+-----------------+--------------------------------+-----------------+
|  backward-char  |Move point left N characters    |       C-b       |
|                 |(right if N is negative).       |                 |
|                 |                                |                 |
+-----------------+--------------------------------+-----------------+

Create table: =M-x table-insert=

=M-x table-span-cell=

=M-x table-split-cell=

=M-x table-heighten-cell=
Enlarge the current cell vertically.


=M-x table-shorten-cell=
Shrink the current cell vertically.


=M-x table-widen-cell=
Enlarge the current cell horizontally.


=M-x table-narrow-cell=
Shrink the current cell horizontally.

* Browsing
** Browsers
#+BEGIN_SRC emacs-lisp
(setq browse-url-browser-function
      (cond ((is-mac-p) 'browse-url-default-macosx-browser)
            ((is-linux-p) 'browse-url-default-browser)))

(bind-key "C-c B" 'browse-url-at-point)

#+END_SRC
* Editing
** Expand

#+BEGIN_SRC emacs-lisp
(use-package expand-region
  :bind (("C-@" . er/expand-region)
         ("C-=" . er/expand-region)
         ("M-3" . er/expand-region)))

(pending-delete-mode t)
#+END_SRC

** Selected
 #+BEGIN_SRC emacs-lisp
 (use-package selected
   :commands selected-minor-mode
   :init
   (setq selected-org-mode-map (make-sparse-keymap))
   (selected-global-mode 1)
   :bind (:map selected-keymap
               ("e" . er/expand-region)
               ("i" . indent-region)
               ("l" . downcase-region)
               ("m" . apply-macro-to-region-lines)
               ("q" . selected-off)
               ("r" . reverse-region)
               ("s" . sort-lines)
               ("u" . upcase-region)
               ("w" . count-words-region)
               ("y" . yank)
               :map selected-org-mode-map
               ("t" . org-table-convert-region)))
 #+END_SRC

** Actionable URL’s

Actionable URLs in Emacs buffers via [[http://xenodium.com/#actionable-urls-in-emacs-buffers][Álvaro Ramírez]].

#+BEGIN_SRC emacs-lisp
(use-package goto-addr
  :hook ((compilation-mode . goto-address-mode)
         (prog-mode . goto-address-prog-mode)
         (eshell-mode . goto-address-mode)
         (shell-mode . goto-address-mode))
  :bind (:map goto-address-highlight-keymap
              ("C-c C-o" . goto-address-at-point))
  :commands (goto-address-prog-mode
             goto-address-mode))
#+END_SRC

** Emojis

#+BEGIN_SRC emacs-lisp
(use-package emojify
  :init (global-emojify-mode))
#+END_SRC

** Line Numbering

#+BEGIN_SRC emacs-lisp
(use-package linum-relative
  :init
  (setq linum-format 'linum-relative)
  :config
  (setq linum-relative-current-symbol ""))
#+END_SRC

** Indenting

#+BEGIN_SRC emacs-lisp
  (use-package aggressive-indent
    :init
    (global-aggressive-indent-mode 1)
    (add-to-list 'aggressive-indent-excluded-modes 'scala-mode)
    (unbind-key "C-c C-q" aggressive-indent-mode-map))
#+END_SRC

Use spaces instead of tab for intentation - 4 spaces

#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil
              tab-width 4)
#+END_SRC

** Spell Check

Install aspell with english dictionary

#+BEGIN_SRC sh
brew install aspell
#+END_SRC

Thanks to [[https://blog.binchen.org/posts/what-s-the-best-spell-check-set-up-in-emacs.html][source]]

#+BEGIN_SRC emacs-lisp
;; find aspell and hunspell automatically
(cond
 ;; try hunspell at first
  ;; if hunspell does NOT exist, use aspell
 ((executable-find "hunspell")
  (setq ispell-program-name "hunspell")
  (setq ispell-local-dictionary "en_US")
  (setq ispell-local-dictionary-alist
        ;; Please note the list `("-d" "en_US")` contains ACTUAL parameters passed to hunspell
        ;; You could use `("-d" "en_US,en_US-med")` to check with multiple dictionaries
        '(("en_US" "[[:alpha:]]" "[^[:alpha:]]" "[']" nil ("-d" "en_US") nil utf-8)
          )))

 ((executable-find "aspell")
  (setq ispell-program-name "aspell")
  ;; Please note ispell-extra-args contains ACTUAL parameters passed to aspell
  (setq ispell-extra-args '("--sug-mode=ultra" "--lang=en_US"))))
#+END_SRC

Check word-spellings in strings and comments

#+BEGIN_SRC emacs-lisp
(use-package flyspell
  :hook (prog-mode . flyspell-prog-mode))
#+END_SRC

** Flycheck

#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :hook (after-init . global-flycheck-mode))
#+END_SRC

** Fixme

Highlight and navigate fixmes

#+BEGIN_SRC
(use-package hi-lock-mode)
#+END_SRC

* Functions
** Emacs Configuration File
This function and the corresponding keybinding allows me to rapidly
access my configuration. They are adapted from Bozhidar Batsov’s post
on Emacs Redux.

#+begin_src emacs-lisp
(defun find-config-file
    ()
  "Edit my emacs config file"
  (interactive)
  (let ((config-file "~/.emacs.d/config.org"))
    (find-file config-file)))

(bind-key "C-c e" 'find-config-file)
#+end_src

#+RESULTS:
: find-config-file

I use mwf-init-file rather than user-init-file, because I edit the
  config file in a Git repo.

#+BEGIN_SRC emacs-lisp
  (defun find-init-file ()
    "Edit my init file in another window."
    (interactive)
    (let ((mwf-init-file "~/.emacs.d/init.el"))
      (find-file mwf-init-file)))

#+END_SRC

Relatedly, I often want to reload my init-file. This will actually use the system-wide user-init-file variable.

#+BEGIN_SRC emacs-lisp
(defun reload-init-file ()
  "Reload my init file."
  (interactive)
  (load-file user-init-file))

(bind-key "C-c M-i" 'reload-init-file)
#+END_SRC

** Debugging

#+BEGIN_SRC emacs-lisp
  ;; activate debugging
  (setq debug-on-error nil
        debug-on-signal nil
        debug-on-quit nil)
#+END_SRC
